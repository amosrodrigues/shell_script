#!/bin/bash
# funcoeszz
#
# INFORMAÃÃES: www.funcoeszz.net
# NASCIMENTO : 22 de Fevereiro de 2000
# AUTORES    : AurÃ©lio Marinho Jargas <verde (a) aurelio net>
#              Thobias Salazar Trevisan <thobias (a) thobias org>
# DESCRIÃÃO  : FunÃ§Ãµes de uso geral para o shell Bash, que buscam
#              informaÃ§Ãµes em arquivos locais e fontes na Internet
# LICENÃA    : GPL
# CHANGELOG  : www.funcoeszz.net/changelog.html
#
ZZVERSAO=8.3
ZZUTF=1
#
##############################################################################
#
#                                ConfiguraÃ§Ã£o
#                                ------------
#
#
### ConfiguraÃ§Ã£o via variÃ¡veis de ambiente
#
# Algumas variÃ¡veis de ambiente podem ser usadas para alterar o comportamento
# padrÃ£o das funÃ§Ãµes. Basta defini-las em seu .bashrc ou na prÃ³pria linha de
# comando antes de chamar as funÃ§Ãµes. SÃ£o elas:
#
#      $ZZCOR    - Liga/Desliga as mensagens coloridas (1 e 0)
#      $ZZPATH   - Caminho completo para o arquivo das funÃ§Ãµes
#      $ZZEXTRA  - Caminho completo para o arquivo com funÃ§Ãµes adicionais
#      $ZZTMPDIR - DiretÃ³rio para armazenar arquivos temporÃ¡rios
#
# Nota: Se vocÃª Ã© paranÃ³ico com seguranÃ§a, configure a ZZTMPDIR para
#       um diretÃ³rio dentro do seu HOME.
#
### ConfiguraÃ§Ã£o fixa neste arquivo (hardcoded)
#
# A configuraÃ§Ã£o tambÃ©m pode ser feita diretamente neste arquivo, se vocÃª
# puder fazer alteraÃ§Ãµes nele.
#
ZZCOR_DFT=1                       # colorir mensagens? 1 liga, 0 desliga
ZZPATH_DFT="/usr/bin/funcoeszz"   # rota absoluta deste arquivo
ZZEXTRA_DFT="$HOME/.zzextra"      # rota absoluta do arquivo de extras
ZZTMPDIR_DFT="${TMPDIR:-/tmp}"    # diretÃ³rio temporÃ¡rio
#
#
##############################################################################
#
#                               InicializaÃ§Ã£o
#                               -------------
#
#
# VariÃ¡veis auxiliares usadas pelas FunÃ§Ãµes ZZ.
# NÃ£o altere nada aqui.
#
#

ZZWWWDUMP='lynx -dump      -nolist -width=300 -accept_all_cookies -display_charset=UTF-8'
ZZWWWLIST='lynx -dump              -width=300 -accept_all_cookies -display_charset=UTF-8'
ZZWWWPOST='lynx -post-data -nolist -width=300 -accept_all_cookies -display_charset=UTF-8'
ZZWWWHTML='lynx -source'
ZZCODIGOCOR='36;1'            # use zzcores para ver os cÃ³digos
ZZSEDURL='s| |+|g;s|&|%26|g;s|@|%40|g'


#
### Truques para descobrir a localizaÃ§Ã£o deste arquivo no sistema
#
# Se a chamada foi pelo executÃ¡vel, o arquivo Ã© o $0.
# SenÃ£o, tenta usar a variÃ¡vel de ambiente ZZPATH, definida pelo usuÃ¡rio.
# Caso nÃ£o exista, usa o local padrÃ£o ZZPATH_DFT.
# Finalmente, forÃ§a que ZZPATH seja uma rota absoluta.
#
[ "${0##*/}" = 'bash' -o "${0#-}" != "$0" ] || ZZPATH="$0"
[ "$ZZPATH" ] || ZZPATH=$ZZPATH_DFT
[ "$ZZPATH" ] || echo 'AVISO: $ZZPATH vazia. zzajuda e zzzz nÃ£o funcionarÃ£o'
[ "${ZZPATH#/}" = "$ZZPATH" ] && ZZPATH="$PWD/${ZZPATH#./}"
[ "$ZZEXTRA" ] || ZZEXTRA=$ZZEXTRA_DFT
[ -f "$ZZEXTRA" ] || ZZEXTRA=
#
### Ãltimos ajustes
#
ZZCOR="${ZZCOR:-$ZZCOR_DFT}"
ZZTMP="${ZZTMPDIR:-$ZZTMPDIR_DFT}/zz"
unset ZZCOR_DFT ZZPATH_DFT ZZEXTRA_DFT ZZTMPDIR_DFT
#
#
##############################################################################


# ----------------------------------------------------------------------------
# Miniferramentas para auxiliar as funÃ§Ãµes.
# Uso: zztool ferramenta [argumentos]
# ----------------------------------------------------------------------------
zztool ()
{
	case "$1" in
		uso)
			# Extrai a mensagem de uso da funÃ§Ã£o $2, usando seu --help
			zzzz -h $2 -h | grep Uso
		;;
		eco)
			shift
			# Mostra mensagem colorida caso $ZZCOR esteja ligada
			if [ "$ZZCOR" != '1' ]
			then
				echo -e "$*"
			else
				echo -e "\033[${ZZCODIGOCOR}m$*\033[m"
			fi
		;;
		acha)
			# Destaca o padrÃ£o $2 no texto via STDIN ou $3
			# O padrÃ£o pode ser uma regex no formato BRE (grep/sed)
			local esc=$(printf '\033')
			local padrao=$(echo "$2" | sed 's,/,\\/,g') # escapa /
			shift; shift
			zztool multi_stdin "$@" |
				if [ "$ZZCOR" != '1' ]
				then
					cat -
				else
		 			sed "s/$padrao/$esc[${ZZCODIGOCOR}m&$esc[m/g"
				fi
		;;
		grep_var)
			# $2 estÃ¡ presente em $3?
			test "${3#*$2}" != "$3"
		;;
		index_var)
			# $2 estÃ¡ em qual posiÃ§Ã£o em $3?
			local padrao="$2"
			local texto="$3"
			if zztool grep_var "$padrao" "$texto"
			then
				texto="${texto%%$padrao*}"
				echo $((${#texto} + 1))
			else
				echo 0
			fi
		;;
		arquivo_vago)
			# Verifica se o nome de arquivo informado estÃ¡ vago
			if test -e "$2"
			then
				echo "Arquivo $2 jÃ¡ existe. Abortando."
				return 1
			fi
		;;
		arquivo_legivel)
			# Verifica se o arquivo existe e Ã© legÃ­vel
			if ! test -r "$2"
			then
				echo "NÃ£o consegui ler o arquivo $2"
				return 1
			fi
			
			# TODO Usar em *todas* as funÃ§Ãµes que lÃªem arquivos
		;;
		testa_numero)
			# Testa se $2 Ã© um nÃºmero positivo
			echo "$2" | grep -qs '^[0-9]\{1,\}$'
			
			# TODO Usar em *todas* as funÃ§Ãµes que recebem nÃºmeros
		;;
		testa_numero_sinal)
			# Testa se $2 Ã© um nÃºmero (pode ter sinal: -2 +2)
			echo "$2" | grep -qs '^[+-]\{0,1\}[0-9]\{1,\}$'
		;;
		testa_binario)
			# Testa se $2 Ã© um nÃºmero binÃ¡rio
			echo "$2" | grep -qs '^[01]\{1,\}$'
		;;
		testa_ip)
			# Testa se $2 Ã© um nÃºmero IP (nnn.nnn.nnn.nnn)
			local nnn="\([0-9]\{1,2\}\|1[0-9][0-9]\|2[0-4][0-9]\|25[0-5]\)" # 0-255
			echo "$2" | grep -qs "^$nnn\.$nnn\.$nnn\.$nnn$"
		;;
		multi_stdin)
			# Mostra na tela os argumentos *ou* a STDIN, nesta ordem
			# Ãtil para funÃ§Ãµes/comandos aceitarem dados das duas formas:
			#     echo texto | funcao
			# ou
			#     funcao texto
			shift
			if [ "$1" ]
			then
				 	echo "$*"
			else
					cat -
			fi
		;;
		trim)
			shift
			zztool multi_stdin "$@" |
		 		sed 's/^[[:blank:]]*// ; s/[[:blank:]]*$//'
		;;
		terminal_utf8)
			echo "$LC_ALL $LC_CTYPE $LANG" | grep -qs -i utf
		;;
		# Ferramentas inexistentes sÃ£o simplesmente ignoradas
		esac
}


# ----------------------------------------------------------------------------
# Mostra uma tela de ajuda com explicaÃ§Ã£o e sintaxe de todas as funÃ§Ãµes.
# Uso: zzajuda
# ----------------------------------------------------------------------------
zzajuda ()
{

	zzzz -h ajuda $1 && return

	# Salva a configuraÃ§Ã£o original de cores
	local zzcor_orig=$ZZCOR

	# Desliga cores para os paginadores antigos
	if [ "$PAGER" = 'less' -o "$PAGER" = 'more' ]
	then
		ZZCOR=0
	fi

	# Mostra ajuda das funÃ§Ãµes padrÃ£o e das extras
	cat $ZZPATH $ZZEXTRA |

		# Magia negra para extrair somente os textos de descriÃ§Ã£o
		sed '
			1 {
				s/.*/** Ajuda das FunÃ§Ãµes ZZ (tecla Q sai)/
				G
				p
			}
			/^# --*$/,/^# --*$/ {
				s/-\{20,\}/-------/
				s/^# //p
			}
			d' |
		uniq |
		sed 's/^-\{7\}/&&&&&&&&&&&/' |
		zztool acha 'zz[a-z0-9]\{2,\}' |
		${PAGER:-less -r}
		
	# Restaura configuraÃ§Ã£o de cores
	ZZCOR=$zzcor_orig
}


# ----------------------------------------------------------------------------
# Mostra informaÃ§Ãµes sobre as funÃ§Ãµes, como versÃ£o e localidade.
# OpÃ§Ãµes: --atualiza  baixa a versÃ£o mais nova das funÃ§Ãµes
#         --teste     testa se a codificaÃ§Ã£o e os prÃ©-requisitos estÃ£o OK
#         --bashrc    instala as funÃ§Ãµes no ~/.bashrc
#         --tcshrc    instala as funÃ§Ãµes no ~/.tcshrc
# Uso: zzzz [--atualiza|--teste|--bashrc|--tcshrc]
# Ex.: zzzz
#      zzzz --teste
# ----------------------------------------------------------------------------
zzzz ()
{
	local nome_func arg_func padrao
	local info_instalado info_cor info_utf8 versao_remota
	local arquivo_aliases arquivo_zz extra
	local bashrc="$HOME/.bashrc"
	local tcshrc="$HOME/.tcshrc"
	local url_site='http://funcoeszz.net'
	local url_exe="$url_site/funcoeszz"
	local instal_msg='Instalacao das Funcoes ZZ (www.funcoeszz.net)'

	case "$1" in

		# AtenÃ§Ã£o: Prepare-se para viajar um pouco que Ã© meio complicado :)
		#
		# Todas as funÃ§Ãµes possuem a opÃ§Ã£o -h e --help para mostrar um
		# texto rÃ¡pido de ajuda. Normalmente cada funÃ§Ã£o teria que
		# implementar o cÃ³digo para verificar se recebeu uma destas opÃ§Ãµes
		# e caso sim, mostrar o texto na tela. Para evitar a repetiÃ§Ã£o de
		# cÃ³digo, estas tarefas estÃ£o centralizadas aqui.
		#
		# Chamando a zzzz com a opÃ§Ã£o -h seguido do nome de uma funÃ§Ã£o e
		# seu primeiro parÃ¢metro recebido, o teste Ã© feito e o texto Ã©
		# mostrado caso necessÃ¡rio.
		#
		# Assim cada funÃ§Ã£o sÃ³ precisa colocar a seguinte linha no inÃ­cio:
		#
		#     zzzz -h beep $1 && return
		#
		# Ao ser chamada, a zzzz vai mostrar a ajuda da funÃ§Ã£o zzbeep caso
		# o valor de $1 seja -h ou --help. Se no $1 estiver qualquer outra
		# opÃ§Ã£o da zzbeep ou argumento, nada acontece.
		#
		# Com o "&& return" no final, a funÃ§Ã£o zzbeep pode sair imediatamente
		# caso a ajuda tenha sido mostrada (retorno zero), ou continuar seu
		# processamento normal caso contrÃ¡rio (retorno um).
		#
		# Se a zzzz -h for chamada sem nenhum outro argumento, Ã© porque o
		# usuÃ¡rio quer ver a ajuda da prÃ³pria zzzz.
		#
		# Nota: Ao invÃ©s de "beep" literal, poderÃ­amos usar $FUNCNAME, mas
		#       o Bash versÃ£o 1 nÃ£o possui essa variÃ¡vel.

		-h | --help)
		
			nome_func=${2#zz}
			arg_func=$3

			# Nenhum argumento, mostre a ajuda da prÃ³pria zzzz
			if ! [ "$nome_func" ]
			then
				nome_func='zz'
				arg_func='-h'
			fi

			# Se o usuÃ¡rio informou a opÃ§Ã£o de ajuda, mostre o texto
			if [ "$arg_func" = '-h' -o "$arg_func" = '--help'  ]
			then
				padrao="Uso: [^ ]*zz$nome_func \{0,1\}"

				# Um xunxo bonito: filtra a saÃ­da da zzajuda, mostrando
				# apenas a funÃ§Ã£o informada.
				zzajuda |
					grep -C9 "^$padrao\b" |
					sed -n "
						H
						/^---/ {
						 	x
							/zz$nome_func/ {
							 	s/----*//gp
								q
							}
						}"
				return 0
			else
			
				# Alarme falso, o argumento nÃ£o Ã© nem -h nem --help
				return 1
			fi
		;;
		
		# Garantia de compatibilidade do -h com o formato antigo (-z):
		# zzzz -z -h zzbeep
		-z)
			zzzz -h $3 $2
		;;

		# Testes de ambiente para garantir o funcionamento das funÃ§Ãµes
		--teste)
		
			### Todos os comandos necessÃ¡rios estÃ£o instalados?
			
			local comando tipo_comando comandos_faltando
			local comandos='awk- bc cat chmod- clear- cp cpp- cut diff- du- find- grep lynx mv od- play- ps- rm sed sleep sort tr uniq'

			for comando in $comandos
			do
				# Este Ã© um comando essencial ou opcional?
				tipo_comando='ESSENCIAL'
				if zztool grep_var - $comando
				then
					tipo_comando='opcional'
					comando=${comando%-}
				fi
				
				printf '%-30s' "Procurando o comando $comando... "

				# Testa se o comando existe
				if type "$comando" >/dev/null 2>&1
				then
					echo 'OK'
				else
					zztool eco "Comando $tipo_comando '$comando' nÃ£o encontrado"
					comandos_faltando="$comando_faltando $tipo_comando"
				fi
			done
			
			if [ "$comandos_faltando" ]
			then
				echo
				zztool eco "**AtenÃ§Ã£o**"
				if zztool grep_var ESSENCIAL $comandos_faltando
				then
					echo 'HÃ¡ pelo menos um comando essencial faltando.'
					echo 'VocÃª precisa instalÃ¡-lo para usar as FunÃ§Ãµes ZZ.'
				else
					echo 'A falta de um comando opcional quebra uma Ãºnica funÃ§Ã£o.'
					echo 'Talvez vocÃª nÃ£o precise instalÃ¡-lo.'
				fi
				echo
			fi
			
			### Tudo certo com a codificaÃ§Ã£o do sistema e das ZZ?

			local cod_sistema='ISO-8859-1'
			local cod_funcoeszz='ISO-8859-1'

			printf 'Verificando a codificaÃ§Ã£o do sistema... '
			zztool terminal_utf8 && cod_sistema='UTF-8'
			echo $cod_sistema

			printf 'Verificando a codificaÃ§Ã£o das FunÃ§Ãµes ZZ... '
			test $ZZUTF = 1 && cod_funcoeszz='UTF-8'
			echo $cod_funcoeszz
			
			# Se um dia precisar de um teste direto no arquivo:
			# sed 1d "$ZZPATH" | file - | grep UTF-8

			if test "$cod_sistema" != "$cod_funcoeszz"
			then
				# Deixar sem acentuaÃ§Ã£o mesmo, pois eles nÃ£o vÃ£o aparecer
				echo
				zztool eco "**Atencao**"
				echo 'Ha uma incompatibilidade de codificacao.'
				echo "Baixe as Funcoes ZZ versao $cod_sistema."
			fi
		;;
		
		# Baixa a versÃ£o nova, caso diferente da local
		--atualiza)

			echo 'Procurando a versÃ£o nova, aguarde.'
			versao_remota=$($ZZWWWDUMP "$url_site/v")
			echo "versÃ£o local : $ZZVERSAO"
			echo "versÃ£o remota: $versao_remota"
			echo

			# Aborta caso nÃ£o encontrou a versÃ£o nova
			[ "$versao_remota" ] || return

			# Compara e faz o download
			if [ "$ZZVERSAO" != "$versao_remota" ]
			then
				# Vamos baixar a versÃ£o ISO-8859-1?
				[ $ZZUTF != '1' ] && url_exe="${url_exe}-iso"

				echo -n 'Baixando a versÃ£o nova... '				
				$ZZWWWHTML "$url_exe" > "funcoeszz-$versao_remota"
				echo 'PRONTO!'
				echo "Arquivo 'funcoeszz-$versao_remota' baixado, instale-o manualmente."
				echo "O caminho atual Ã© $ZZPATH"
			else
				echo 'VocÃª jÃ¡ estÃ¡ com a versÃ£o mais recente.'
			fi
		;;
		
		# Instala as funÃ§Ãµes no arquivo .bashrc
		--bashrc)
		
			if ! grep -qs "^[^#]*${ZZPATH:-zzpath_vazia}" "$bashrc"
			then
				(
					echo
					echo "# $instal_msg"
					echo "source $ZZPATH"
					echo "export ZZPATH=$ZZPATH"
				) >> "$bashrc"
				
				echo 'Feito!'
				echo "As FunÃ§Ãµes ZZ foram instaladas no $bashrc"
			else
				echo "Nada a fazer. As FunÃ§Ãµes ZZ jÃ¡ estÃ£o no $bashrc"
			fi
		;;
	
		# Cria aliases para as funÃ§Ãµes no arquivo .tcshrc
		--tcshrc)
			arquivo_aliases="$HOME/.zzcshrc"
			
			# Chama o arquivo dos aliases no final do .tcshrc
			if ! grep -qs "^[^#]*$arquivo_aliases"  "$tcshrc"
			then
				(
					echo
					echo "# $instal_msg"
					echo "source $arquivo_aliases"
					echo "setenv ZZPATH $ZZPATH"
				) >> "$tcshrc"
				echo 'Feito!'
				echo "As FunÃ§Ãµes ZZ foram instaladas no $tcshrc"
			else
				echo "Nada a fazer. As FunÃ§Ãµes ZZ jÃ¡ estÃ£o no $tcshrc"
			fi
			
			# Cria o arquivo de aliases
			echo > $arquivo_aliases
			for func in $(ZZCOR=0 zzzz | sed '1,/^(( fu/d; /^(/d; s/,//g')
			do
				echo "alias zz$func 'funcoeszz zz$func'" >> "$arquivo_aliases"
			done
			echo
			echo "Aliases atualizados no $arquivo_aliases"
		;;

		# Mostra informaÃ§Ãµes sobre as funÃ§Ãµes
		*)
			# As funÃ§Ãµes estÃ£o configuradas para usar cores?
			[ "$ZZCOR" = '1' ] && info_cor='sim' || info_cor='nÃ£o'

			# A codificaÃ§Ã£o do arquivo das funÃ§Ãµes Ã© UTF-8?
			[ "$ZZUTF" = 1 ] && info_utf8='UTF-8' || info_utf8='ISO-8859-1'
			
			# As funÃ§Ãµes estÃ£o instaladas no bashrc?
			if grep -qs "^[^#]*${ZZPATH:-zzpath_vazia}" "$bashrc"
			then
				info_instalado="$bashrc"
			else
				info_instalado='nÃ£o instalado'
			fi
			
			# InformaÃ§Ãµes, uma por linha
			zztool acha '^[^)]*)' "( local) $ZZPATH"
			zztool acha '^[^)]*)' "(versÃ£o) $ZZVERSAO ($info_utf8)"
			zztool acha '^[^)]*)' "( cores) $info_cor"
			zztool acha '^[^)]*)' "(   tmp) $ZZTMP"
			zztool acha '^[^)]*)' "(bashrc) $info_instalado"
			zztool acha '^[^)]*)' "(extras) ${ZZEXTRA:-nenhum}"
			zztool acha '^[^)]*)' "(  site) $url_site"
						
			# Lista de todas as funÃ§Ãµes
			for arquivo_zz in "$ZZPATH" "$ZZEXTRA"
			do
				if [ "$arquivo_zz" -a -f "$arquivo_zz" ]
				then
					echo
					zztool eco "(( funÃ§Ãµes disponÃ­veis ${extra:+EXTRA }))"
					# Nota: zzzz --tcshrc procura por " fu"
					
					# Sed mÃ¡gico que extrai e formata os nomes de funÃ§Ãµes
					# limitando as linhas em 60 colunas
					sed -n '/^zz\([a-z0-9]\{1,\}\) *(.*/s//\1/p' "$arquivo_zz" |
						sort |
						sed -e ':a' -e '$b' -e 'N; s/\n/, /; /.\{60\}/{p;d;};ba'
						
					# Flag tosca para identificar a segunda volta do loop
					extra=1
				fi
			done
		;;
	esac
}



# ----------------------------------------------------------------------------
# #### D I V E R S O S
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# Mostra uma seqÃ¼Ãªncia numÃ©rica, um nÃºmero por linha.
# Obs.: EmulaÃ§Ã£o do comando seq, presente no Linux.
# Uso: zzseq [nÃºmero-inicial] nÃºmero-final
# Ex.: zzseq 5
#      zzseq 10 5
# ----------------------------------------------------------------------------
# TODO aceitar terceiro parÃ¢metro, igual no Linux: 10 -2 0 (inÃ­cio step fim)
zzseq ()
{
	zzzz -h seq $1 && return

	local operacao='+'
	local inicio=1
	local fim=$1

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso seq; return; }
	
	# Se houver dois nÃºmeros, vai "do primeiro ao segundo"
	[ "$2" ] && inicio=$1 fim=$2

	# VerificaÃ§Ãµes bÃ¡sicas
	if ! (zztool testa_numero_sinal "$inicio" &&
	      zztool testa_numero_sinal "$fim")
	then
		zztool uso seq
		return
	fi
	
	# Se o primeiro for maior que o segundo, a contagem Ã© regressiva
	[ $inicio -gt $fim ] && operacao='-'
	
	# Loop que mostra o nÃºmero e aumenta/diminui a contagem
	while [ $inicio -ne $fim ]
	do
		echo $inicio
		eval "inicio=\$((inicio $operacao 1))" # +1 ou -1
	done
	echo $inicio
}


# ----------------------------------------------------------------------------
# ConversÃ£o entre grandezas de bytes (mega, giga, tera, etc).
# Uso: zzbyte N [unidade-entrada] [unidade-saida]  # BKMGTPEZY
# Ex.: zzbyte 2048                    # Quanto Ã© 2048 bytes?  -- 2K
#      zzbyte 2048 K                  # Quanto Ã© 2048KB?      -- 2M
#      zzbyte 7 K M                   # Quantos megas em 7KB? -- 0.006M
#      zzbyte 7 G B                   # Quantos bytes em 7GB? -- 7516192768B
#      for u in b k m g t p e z y; do zzbyte 2 t $u; done
# ----------------------------------------------------------------------------
zzbyte ()
{
	zzzz -h byte $1 && return

	local i i_entrada i_saida diferenca operacao passo falta
	local unidades='BKMGTPEZY' # kilo, mega, giga, etc
	local n=$1
	local entrada=${2:-B}
	local saida=${3:-.}
	
	# Sejamos amigÃ¡veis com o usuÃ¡rio permitindo minÃºsculas tambÃ©m
	entrada=$(echo $entrada | zzmaiusculas)
	saida=$(  echo $saida   | zzmaiusculas)

	# VerificaÃ§Ãµes bÃ¡sicas
	if ! zztool testa_numero $n
	then
		zztool uso byte
		return
	fi
	if ! zztool grep_var $entrada $unidades
	then
		echo "Unidade invÃ¡lida '$entrada'"
		return
	fi
	if ! zztool grep_var $saida .$unidades
	then
		echo "Unidade invÃ¡lida '$saida'"
		return
	fi
	
 	# Extrai os nÃºmeros (Ã­ndices) das unidades de entrada e saÃ­da
	i_entrada=$(zztool index_var $entrada $unidades)
	i_saida=$(  zztool index_var $saida   $unidades)
		
	# Sem $3, a unidade de saÃ­da serÃ¡ otimizada
	[ $i_saida -eq 0 ] && i_saida=15

	# A diferenÃ§a entre as unidades guiarÃ¡ os cÃ¡lculos
	diferenca=$((i_saida - i_entrada))
	if [ $diferenca -lt 0 ]
	then
	 	operacao='*'
	 	passo='-'
	else
		operacao='/'
		passo='+'
	fi
	
	i=$i_entrada
	while [ $i -ne $i_saida ]
	do
		# SaÃ­da automÃ¡tica (sem $3)
		# Chegamos em um nÃºmero menor que 1024, hora de sair
		[ $n -lt 1024 -a $i_saida -eq 15 ] && break
		
		# NÃ£o ultrapasse a unidade mÃ¡xima (Yota)
		[ $i -eq ${#unidades} -a $passo = '+' ] && break
		
		# 0 < n < 1024 para unidade crescente, por exemplo: 1 B K
		# Ã hora de dividir com float e colocar zeros Ã  esquerda
		if [ $n -gt 0 -a $n -lt 1024 -a $passo = '+' ]
		then
			# Quantos dÃ­gitos ainda faltam?
			falta=$(( (i_saida - i - 1) * 3))
						
			# Pulamos direto para a unidade final
			i=$i_saida
			
			# CÃ¡lculo preciso usando o bc (Retorna algo como .090)
			n=$(echo "scale=3; $n / 1024" | bc)
			[ $n = '0' ] && break # 1 / 1024 = 0

			# Completa os zeros que faltam
			[ $falta -gt 0 ] && n=$(printf "%0.${falta}f%s" 0 ${n#.})
			
			# Coloca o zero na frente, caso necessÃ¡rio
			[ "${n#.}" != "$n" ] && n=0$n
			
			break
		fi
		
		# Terminadas as exceÃ§Ãµes, este Ã© o processo normal
		# Aumenta/diminui a unidade e divide/multiplica por 1024
		eval "i=$((i $passo 1))"
		eval "n=$((n $operacao 1024))"
	done
	
	# Mostra o resultado
	echo $n$(echo $unidades | cut -c$i)
}


# ----------------------------------------------------------------------------
# Aguarda N minutos e dispara uma sirene usando o 'speaker'.
# Ãtil para lembrar de eventos prÃ³ximos no mesmo dia.
# Sem argumentos, restaura o 'beep' para o seu tom e duraÃ§Ã£o originais.
# Obs.: A sirene tem 4 toques, sendo 2 tons no modo texto e apenas 1 no Xterm.
# Uso: zzbeep [nÃºmeros]
# Ex.: zzbeep 0
#      zzbeep 1 5 15    # espere 1 minuto, depois mais 5, e depois 15
# ----------------------------------------------------------------------------
zzbeep ()
{
	zzzz -h beep $1 && return
	
	local minutos frequencia
	 
	# Sem argumentos, apenas restaura a "configuraÃ§Ã£o de fÃ¡brica" do beep
	[ "$1" ] || {
		printf '\033[10;750]\033[11;100]\a'
		return
	}
	
	# Para cada quantidade informada pelo usuÃ¡rio...
	for minutos in $*
	do
		# Aguarda o tempo necessÃ¡rio
		echo -n "Vou bipar em $minutos minutos... "
		sleep $((minutos*60))
		
		# Ajusta o beep para toque longo (Linux modo texto)
		printf '\033[11;900]'
		
		# Alterna entre duas freqÃ¼Ãªncias, simulando uma sirene (Linux)
		for frequencia in 500 400 500 400
		do
			printf "\033[10;$frequencia]\a"
			sleep 1
		done
		
		# Restaura o beep para toque normal
		printf '\033[10;750]\033[11;100]'
		echo OK
	done
}


# ----------------------------------------------------------------------------
# Retira linhas em branco e comentÃ¡rios.
# Para ver rapidamente quais opÃ§Ãµes estÃ£o ativas num arquivo de configuraÃ§Ã£o.
# AlÃ©m do tradicional #, reconhece comentÃ¡rios de arquivos .vim.
# Obs.: Aceita dados vindos da entrada padrÃ£o (STDIN).
# Uso: zzlimpalixo [arquivos]
# Ex.: zzlimpalixo ~/.vimrc
#      cat /etc/inittab | zzlimpalixo
# ----------------------------------------------------------------------------
zzlimpalixo ()
{
	zzzz -h limpalixo $1 && return

	local comentario='#'

	# Reconhecimento de comentÃ¡rios do Vim
	case "$1" in
		*.vim | *.vimrc*)
			comentario='"'
		;;
	esac

	# Remove comentÃ¡rios e linhas em branco
	cat "${@:--}" |
		sed "
			/^[[:blank:]]*$comentario/ d
			/^[[:blank:]]*$/ d" |
		uniq
}


# ----------------------------------------------------------------------------
# ConversÃ£o de letras entre minÃºsculas e MAIÃSCULAS, inclusive acentuadas.
# Uso: zzmaiusculas [arquivo]
# Uso: zzminusculas [arquivo]
# Ex.: zzmaiusculas /etc/passwd
#      echo NÃO ESTOU GRITANDO | zzminusculas
# ----------------------------------------------------------------------------
zzminusculas ()
{
	zzzz -h minusculas $1 && return
	
	sed '
		y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
	 	y/ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ/Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã²Ã³Ã´ÃµÃ¶Ã¹ÃºÃ»Ã¼Ã§Ã±/' "$@"
}
zzmaiusculas ()
{
	zzzz -h maiusculas $1 && return
	
	sed '
		y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
	 	y/Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã²Ã³Ã´ÃµÃ¶Ã¹ÃºÃ»Ã¼Ã§Ã±/ÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃÃ/' "$@"
}


# ----------------------------------------------------------------------------
# Retira as linhas repetidas, consecutivas ou nÃ£o.
# Obs.: NÃ£o altera a ordem original das linhas, diferente do sort|uniq.
# Uso: zzuniq [arquivo]
# Ex.: zzuniq /etc/inittab
#      cat /etc/inittab | zzuniq
# ----------------------------------------------------------------------------
zzuniq ()
{
	zzzz -h uniq $1 && return

	# As linhas do arquivo sÃ£o numeradas para guardar a ordem original
	cat -n "${1:--}" |     # Numera as linhas do arquivo
		sort -k2 -u |  # Ordena e remove duplos, ignorando a numeraÃ§Ã£o
		sort -n |      # Restaura a ordem original
		cut -f2-       # Remove a numeraÃ§Ã£o

	# VersÃ£o SED, mais lenta para arquivos grandes, mas sÃ³ precisa do SED
	# PATT: LINHA ATUAL \n LINHA-1 \n LINHA-2 \n ... \n LINHA #1 \n
	# sed "G ; /^\([^\n]*\)\n\([^\n]*\n\)*\1\n/d ; h ; s/\n.*//" $1
		
}


# ----------------------------------------------------------------------------
# Mata processos pelo nome do seu comando de origem.
# Com a opÃ§Ã£o -n, apenas mostra o que serÃ¡ feito, mas nÃ£o executa.
# Uso: zzkill [-n] comando [comando2 ...]
# Ex.: zzkill netscape
#      zzkill netsc soffice startx
# ----------------------------------------------------------------------------
zzkill ()
{
	zzzz -h kill $1 && return

	local nao comandos comando processos pid chamada

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-n' ]
	then
		nao='[-n]\t'
		shift
	fi

	while :
	do
		comando="$1"
		
		# Tenta obter a lista de processos nos formatos Linux e BSD
		processos=$(ps xw --format pid,comm 2>/dev/null) ||
		processos=$(ps xw -o pid,command 2>/dev/null)

		 # Diga nÃ£o ao suicÃ­dio
		processos=$(echo "$processos" | grep -vw '\(zz\)*kill')
		
		# Sem argumentos, apenas mostra a listagem e sai
		if ! [ "$1" ]
		then
			echo "$processos"
			return
		fi
		
		# Filtra a lista, extraindo e matando os PIDs
		echo "$processos" |
			grep -i "$comando" |
			while read pid chamada
			do
				echo -e "$nao$pid\t$chamada"
				[ "$nao" ] || kill $pid
			done
		
		# PrÃ³ximo da fila!
		shift
		[ "$1" ] || break
	done
}


# ----------------------------------------------------------------------------
# Mostra todas as combinaÃ§Ãµes de cores possÃ­veis no console.
# TambÃ©m mostra os cÃ³digos ANSI para obter tais combinaÃ§Ãµes.
# Uso: zzcores
# ----------------------------------------------------------------------------
zzcores ()
{
	zzzz -h cores $1 && return

	local frente fundo negrito cor

	for frente in 0 1 2 3 4 5 6 7
	do
		for negrito in '' ';1' # alterna entre linhas sem e com negrito
		do
			for fundo in 0 1 2 3 4 5 6 7
			do
				# CompÃµe o par de cores: NN;NN
				cor="4$fundo;3$frente"
				
				# Mostra na tela usando caracteres de controle: ESC[ NN m
				printf "\033[$cor${negrito}m $cor${negrito:-  } \033[m"
			done
			echo
		done
	done
}


# ----------------------------------------------------------------------------
# Gera uma senha aleatÃ³ria de N caracteres formada por letras e nÃºmeros.
# Obs.: A senha gerada nÃ£o possui caracteres repetidos.
# Uso: zzsenha [n]     (padrÃ£o n=6)
# Ex.: zzsenha
#      zzsenha 8
# ----------------------------------------------------------------------------
zzsenha ()
{
	zzzz -h senha $1 && return

	local posicao letra
	local n=6
	local alpha='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
	local maximo=${#alpha}

	# Guarda o nÃºmero informado pelo usuÃ¡rio (se existente)
	[ "$1" ] && n=$1
	
	# Foi passado um nÃºmero mesmo?
	if ! zztool testa_numero "$n"
	then
		zztool uso senha
		return
	fi

	# JÃ¡ que nÃ£o repete as letras, temos uma limitaÃ§Ã£o de tamanho
	if [ $n -gt $maximo ]
	then
		echo "O tamanho mÃ¡ximo da senha Ã© $maximo"
		return
	fi
	
	# Esquema de geraÃ§Ã£o da senha:
	# A cada volta Ã© escolhido um nÃºmero aleatÃ³rio que indica uma
	# posiÃ§Ã£o dentro do $alpha. A letra dessa posiÃ§Ã£o Ã© mostrada na
	# tela e removida do $alpha para nÃ£o ser reutilizada.
	while [ $n -ne 0 ]
	do
		n=$((n-1))
		posicao=$((RANDOM % ${#alpha} + 1))
		letra=$(echo -n "$alpha" | cut -c$posicao)
		alpha=$(echo $alpha | tr -d $letra)
		echo -n $letra
	done
	echo
}


# ----------------------------------------------------------------------------
# Mostra a tabela ASCII com todos os caracteres imprimÃ­veis (32-126,161-255).
# O formato utilizando Ã©: <decimal> <hexa> <octal> <ascii>.
# O nÃºmero de colunas e a largura da tabela sÃ£o configurÃ¡veis.
# Uso: zzascii [colunas] [largura]
# Ex.: zzascii
#      zzascii 4
#      zzascii 7 100
# ----------------------------------------------------------------------------
zzascii ()
{
	zzzz -h ascii $1 && return

	local referencias decimais decimal hexa octal caractere
	local num_colunas=${1:-5}
	local largura=${2:-78}
	local linha=0
	
	# Estamos em um terminal UTF-8?
	if zztool terminal_utf8
	then
		decimais=$(zzseq 32 126)
	else
		# Se o sistema for ISO-8859-1, mostra a tabela extendida,
		# com caracteres acentuados
		decimais=$(zzseq 32 126 ; zzseq 161 255)
	fi

	# CÃ¡lculos das dimensÃµes da tabela
	local colunas=$(zzseq 0 $((num_colunas - 1)))
	local largura_coluna=$((largura / num_colunas))
	local num_caracteres=$(echo "$decimais" | sed -n '$=')
	local num_linhas=$((num_caracteres / num_colunas + 1))

	# Mostra as dimensÃµes
	echo $num_caracteres caracteres, $num_colunas colunas, $num_linhas linhas, $largura de largura
	
	# Linha a linha...
	while [ $linha -lt $num_linhas ]
	do
		linha=$((linha+1))

		# Extrai as referÃªncias (nÃºmero da linha dentro do $decimais)
		# para cada caractere que serÃ¡ mostrado nesta linha da tabela.
		# Ã montado um comando Sed com eles: 5p; 10p; 13p;
		referencias=''
		for col in $colunas
		do
			referencias="$referencias $((num_linhas * col + linha))p;"
		done
		
		# Usando as referÃªncias coletadas, percorre cada decimal
		# que serÃ¡ usado nesta linha da tabela
		for decimal in $(echo "$decimais" | sed -n "$referencias")
		do
			hexa=$( printf '%X'   $decimal)
			octal=$(printf '%03o' $decimal) # NNN
			caractere=$(printf "\x$hexa")
			
			# Mostra a cÃ©lula atual da tabela
			printf "%${largura_coluna}s" "$decimal $hexa $octal $caractere"
		done
		echo
	done
}


# ----------------------------------------------------------------------------
# Protetor de tela (Screen Saver) para console, com cores e temas.
# Temas: mosaico, espaco, olho, aviao, jacare, alien, rosa, peixe, siri.
# Obs.: Aperte Ctrl+C para sair.
# Uso: zzss [--rapido|--fundo] [--tema <tema>] [texto]
# Ex.: zzss
#      zzss fui ao banheiro
#      zzss --rapido /
#      zzss --fundo --tema peixe
# ----------------------------------------------------------------------------
zzss ()
{
	zzzz -h ss $1 && return

	local mensagem tamanho_mensagem mensagem_colorida
	local cor_fixo cor_muda negrito codigo_cores fundo
	local linha coluna dimensoes
	local linhas=25
	local colunas=80
	local tema='mosaico'
	local pausa=1

	local temas='
		mosaico	#
		espaco	.
 		olho	00
		aviao	--o-0-o--
		jacare	==*-,,--,,--
	   	alien	/-=-\
		rosa	--/--\-<@
		peixe	>-)))-D
 		siri	(_).-=''=-.(_)
	'
	
	# Tenta obter as dimensÃµes atuais da tela/janela
	dimensoes=$(stty size 2>/dev/null)
	if [ "$dimensoes" ]
	then
		linhas=${dimensoes% *}
		colunas=${dimensoes#* }
	fi
	
	# OpÃ§Ãµes de linha de comando
	while [ $# -ge 1 ]
	do
		case "$1" in
			--fundo)
				fundo=1
			;;
			--rapido)
				unset pausa
			;;
			--tema)
				[ "$2" ] || { zztool uso ss; return; }
				tema=$2
				shift
			;;
			*)
				mensagem="$*"
				unset tema
				break
			;;
		esac
		shift
	done
	
	# Extrai a mensagem (desenho) do tema escolhido
	if [ "$tema" ]
	then
		mensagem=$(
			echo "$temas" |
		 		grep -w "$tema" |
				zztool trim |
				cut -f2
		)
	
		if ! [ "$mensagem" ]
		then
			echo "Tema desconhecido '$tema'"
			return
		fi
	fi
	
	# O 'mosaico' Ã© um tema especial que precisa de ajustes
	if [ "$tema" = 'mosaico' ]
	then
		# ConfiguraÃ§Ãµes para mostrar retÃ¢ngulos coloridos frenÃ©ticos
		mensagem=' '
		fundo=1
		unset pausa
	fi

	# Define se a parte fixa do cÃ³digo de cores serÃ¡ fundo ou frente
	if [ "$fundo" ]
	then
	 	cor_fixo='30;4'
	else
		cor_fixo='40;3'
	fi

	# EntÃ£o vamos comeÃ§ar, primeiro limpando a tela
	clear
	
	# O 'trap' mapeia o Ctrl-C para sair do Screen Saver
	( trap "clear;return" 2
	
	tamanho_mensagem=${#mensagem}
	
	while :
	do
		# Posiciona o cursor em um ponto qualquer (aleatÃ³rio) da tela (X,Y)
		# Detalhe: A mensagem sempre cabe inteira na tela ($coluna)
		linha=$((RANDOM % linhas + 1))
		coluna=$((RANDOM % (colunas - tamanho_mensagem + 1) + 1))
		printf "\033[$linha;${coluna}H"
		
		# Escolhe uma cor aleatÃ³ria para a mensagem (ou o fundo): 1 - 7
		cor_muda=$((RANDOM % 7 + 1))

		# Usar negrito ou nÃ£o tambÃ©m Ã© escolhido ao acaso: 0 - 1
		negrito=$((RANDOM % 2))
		
		# Podemos usar cores ou nÃ£o?
		if [ "$ZZCOR" = 1 ]
		then
			codigo_cores="$negrito;$cor_fixo$cor_muda"
			mensagem_colorida="\033[${codigo_cores}m$mensagem\033[m"
		else
			mensagem_colorida="$mensagem"
		fi

		# Mostra a mensagem/desenho na tela e (talvez) espera 1s
		printf "$mensagem_colorida"
		${pausa:+sleep 1}
	done )
}


# ----------------------------------------------------------------------------
# ConversÃ£o de telefones contendo letras para apenas nÃºmeros.
# Uso: zzfoneletra telefone
# Ex.: zzfoneletra 2345-LINUX              # Retorna 2345-54689
#      echo 5555-HELP | zzfoneletra        # Retorna 5555-4357
# ----------------------------------------------------------------------------
zzfoneletra ()
{
	zzzz -h foneletra $1 && return

	# Um Sed faz tudo, Ã© uma traduÃ§Ã£o letra a letra
	zztool multi_stdin $* |
	 	zzmaiusculas |
	 	sed y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/22233344455566677778889999/
}



# ----------------------------------------------------------------------------
# #### A R Q U I V O S
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# Converte arquivos texto no formato Windows/DOS (CR+LF) para o Unix (LF).
# Obs.: TambÃ©m remove a permissÃ£o de execuÃ§Ã£o do arquivo, caso presente.
# Uso: zzdos2unix arquivo(s)
# Ex.: zzdos2unix frases.txt
# ----------------------------------------------------------------------------
zzdos2unix ()
{
	zzzz -h dos2unix $1 && return

	local arquivo
	local tmp="$ZZTMP.dos2unix.$$"

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dos2unix; return; }
	
	for arquivo in "$@"
	do
		# O arquivo existe?
		zztool arquivo_legivel "$arquivo" || continue
		
		# Remove o famigerado CR \r ^M 
		cp "$arquivo" "$tmp" &&
		tr -d '\015' < "$tmp" > "$arquivo"
		
		# SeguranÃ§a
		if [ $? -ne 0 ]
		then
			echo "Ops, algum erro ocorreu em $arquivo"
			echo "Seu arquivo original estÃ¡ guardado em $tmp"
			return
		fi
		
		# Remove a permissÃ£o de execuÃ§Ã£o, comum em arquivos DOS
		chmod -x "$arquivo"
		
 		echo "Convertido $arquivo"
	done
	
	# Remove o arquivo temporÃ¡rio
	rm "$tmp"
}


# ----------------------------------------------------------------------------
# Converte arquivos texto no formato Unix (LF) para o Windows/DOS (CR+LF).
# Uso: zzunix2dos arquivo(s)
# Ex.: zzunix2dos frases.txt
# ----------------------------------------------------------------------------
zzunix2dos ()
{
	zzzz -h unix2dos $1 && return

	local arquivo
	local tmp="$ZZTMP.unix2dos.$$"
	local control_m=$(printf '\r') # ^M / CR

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso unix2dos; return; }
	
	for arquivo in "$@"
	do
		# O arquivo existe?
		zztool arquivo_legivel "$arquivo" || continue
		
		# Adiciona um Ãºnico CR no final de cada linha
		cp "$arquivo" "$tmp" &&
		sed "s/$control_m*$/$control_m/" "$tmp" > "$arquivo"
		
		# SeguranÃ§a
		if [ $? -ne 0 ]
		then
			echo "Ops, algum erro ocorreu em $arquivo"
			echo "Seu arquivo original estÃ¡ guardado em $tmp"
			return
		fi
				
 		echo "Convertido $arquivo"
	done
	
	# Remove o arquivo temporÃ¡rio
	rm "$tmp"
}


# ----------------------------------------------------------------------------
# Troca a extensÃ£o dos arquivos especificados.
# Com a opÃ§Ã£o -n, apenas mostra o que serÃ¡ feito, mas nÃ£o executa.
# Uso: zztrocaextensao [-n] antiga nova arquivo(s)
# Ex.: zztrocaextensao -n .doc .txt *          # tire o -n para renomear!
# ----------------------------------------------------------------------------
zztrocaextensao ()
{
	zzzz -h trocaextensao $1 && return
	
	local ext1 ext2 arquivo base novo nao

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-n' ]
	then
		nao='[-n] '
		shift
	fi

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$3" ] || { zztool uso trocaextensao; return; }
	
	# Guarda as extensÃµes informadas
	ext1="$1"
	ext2="$2"
	shift; shift
	
	# Tiro no pÃ©? NÃ£o, obrigado
	[ "$ext1" = "$ext2" ] && return
	
	# Para cada arquivo informado...
	for arquivo in "$@"
	do
		# O arquivo existe?
		zztool arquivo_legivel "$arquivo" || continue
	
		base="${arquivo%$ext1}"
		novo="$base$ext2"

		# Testa se o arquivo possui a extensÃ£o antiga
		[ "$base" != "$arquivo" ] || continue

		# Mostra o que serÃ¡ feito
		echo "$nao$arquivo -> $novo"

		# Se nÃ£o tiver -n, vamos renomear o arquivo
		if [ ! "$nao" ]
		then
			# NÃ£o sobrescreve arquivos jÃ¡ existentes
			zztool arquivo_vago "$novo" || return

			# Vamos lÃ¡
			mv -- "$arquivo" "$novo"
		fi
	done
}


# ----------------------------------------------------------------------------
# Troca o conteÃºdo de dois arquivos, mantendo suas permissÃµes originais.
# Uso: zztrocaarquivos arquivo1 arquivo2
# Ex.: zztrocaarquivos /etc/fstab.bak /etc/fstab
# ----------------------------------------------------------------------------
zztrocaarquivos ()
{
	zzzz -h trocaarquivos $1 && return
	
	# Um terceiro arquivo Ã© usado para fazer a troca
	local tmp="$ZZTMP.trocaarquivos.$$"

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$#" -eq 2 ] || { zztool uso trocaarquivos; return; }

	# Verifica se os arquivos existem
	zztool arquivo_legivel "$1" || return
	zztool arquivo_legivel "$2" || return

	# Tiro no pÃ©? NÃ£o, obrigado
	[ "$1" = "$2" ] && return
	
	# A danÃ§a das cadeiras
	cat "$2"   > "$tmp"
	cat "$1"   > "$2"
	cat "$tmp" > "$1"
	
	# E foi
	rm "$tmp"
	echo "Feito: $1 <-> $2"
}


# ----------------------------------------------------------------------------
# Troca uma palavra por outra, nos arquivos especificados.
# Obs.: AlÃ©m de palavras, Ã© possÃ­vel usar expressÃµes regulares.
# Uso: zztrocapalavra antiga nova arquivo(s)
# Ex.: zztrocapalavra excessÃ£o exceÃ§Ã£o *.txt
# ----------------------------------------------------------------------------
# TODO -r (ver zzarrumanome)
zztrocapalavra ()
{
	zzzz -h trocapalavra $1 && return
	
	local arquivo antiga_escapada nova_escapada
	local antiga="$1"
	local nova="$2"

	# Precisa do temporÃ¡rio pois nem todos os Sed possuem a opÃ§Ã£o -i
	local tmp="$ZZTMP.trocapalavra.$$"
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$3" ] || { zztool uso trocapalavra; return; }

	# Escapando a barra "/" dentro dos textos de pesquisa
	antiga_escapada=$(echo "$antiga" | sed 's,/,\\/,g')
	nova_escapada=$(  echo "$nova"   | sed 's,/,\\/,g')

	shift; shift
	for arquivo in "$@"
	do
		# O arquivo existe?
		zztool arquivo_legivel "$arquivo" || continue
	
		# Um teste rÃ¡pido para saber se o arquivo tem a palavra antiga,
		# evitando gravar o temporÃ¡rio desnecessariamente
		grep -qs "$antiga" "$arquivo" || continue
		
		# Uma seqÃ¼Ãªncia encadeada de comandos para garantir que estÃ¡ OK
		cp "$arquivo" "$tmp" &&
		sed "s/$antiga_escapada/$nova_escapada/g" "$tmp" > "$arquivo" && {
			echo "Feito $arquivo" # EstÃ¡ retornando 1 :/
			continue
		}
		
		# Em caso de erro, recupera o conteÃºdo original
		echo
		echo "Ops, deu algum erro no arquivo $arquivo"
		echo "Uma cÃ³pia dele estÃ¡ em $tmp"
		cat "$tmp" > "$arquivo"
		return
	done
	rm -f "$tmp"
}


# ----------------------------------------------------------------------------
# Renomeia arquivos do diretÃ³rio atual, arrumando nomes estranhos.
# Obs.: Ele deixa tudo em minÃºsculas, retira acentuaÃ§Ã£o e troca espaÃ§os em
#       branco, sÃ­mbolos e pontuaÃ§Ã£o pelo sublinhado _.
# OpÃ§Ãµes: -n  apenas mostra o que serÃ¡ feito, nÃ£o executa
#         -d  tambÃ©m renomeia diretÃ³rios
#         -r  funcionamento recursivo (entra nos diretÃ³rios)
# Uso: zzarrumanome [-n] [-d] [-r] arquivo(s)
# Ex.: zzarrumanome *
#      zzarrumanome -n -d -r .                   # tire o -n para renomear!
#      zzarrumanome "DOCUMENTO MALÃO!.DOC"       # fica documento_malao.doc
#      zzarrumanome "RAMONES - Don't Go.mp3"     # fica ramones-dont_go.mp3
# ----------------------------------------------------------------------------
zzarrumanome ()
{
	zzzz -h arrumanome $1 && return

	local arquivo caminho antigo novo recursivo pastas nao i

	# OpÃ§Ãµes de linha de comando
	while [ "${1#-}" != "$1" ]
	do
		case "$1" in
			-d) pastas=1    ;;
			-r) recursivo=1 ;;
			-n) nao="[-n] " ;;
			 *) break       ;;
		esac
		shift
	done
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso arrumanome; return; }
	
	# Para cada arquivo que o usuÃ¡rio informou...
	for arquivo in "$@"
	do
		# Tira a barra no final do nome da pasta
		[ "$arquivo" != / ] && arquivo=${arquivo%/}
		
		# Ignora arquivos e pastas nÃ£o existentes
		[ -f "$arquivo" -o -d "$arquivo" ] || continue
		
		# Se for uma pasta...
		if test -d "$arquivo"
		then
			# Arruma arquivos de dentro dela (-r)
			[ "${recursivo:-0}" -eq 1 ] &&
			 	zzarrumanome -r ${pastas:+-d} ${nao:+-n} "$arquivo"/*
			
			# NÃ£o renomeia nome da pasta (se nÃ£o tiver -d)
			[ "${pastas:-0}" -ne 1 ] && continue
		fi
		
		# A pasta vai ser a corrente ou o 'dirname' do arquivo (se tiver)
		caminho='.'
		zztool grep_var / "$arquivo" && caminho="${arquivo%/*}"
		
		# $antigo Ã© o arquivo sem path (basename)
		antigo="${arquivo##*/}"
		
		# $novo Ã© o nome arrumado com a magia negra no Sed
		novo=$(
			echo $antigo | # Sem aspas para aproveitar o 'squeeze'
			zzminusculas |
			sed -e "
				# Remove aspas
				s/[\"']//g
				
				# HÃ­fens no inÃ­cio do nome sÃ£o proibidos
  				s/^-/_/
				
				# Remove acentos
				y/Ã Ã¡Ã¢Ã£Ã¤Ã¥Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã²Ã³Ã´ÃµÃ¶Ã¹ÃºÃ»Ã¼/aaaaaaeeeeiiiiooooouuuu/
				y/Ã§Ã±ÃÂ¢ÃÂ£ÃÃ¸Â§ÂµÃÃ½Â¥Â¹Â²Â³/cnbcdloosuyyy123/
				
				# Qualquer caractere estranho vira sublinhado
				s/[^a-z0-9._-]/_/g
				
				# Remove sublinhados consecutivos
				s/__*/_/g
				
				# Remove sublinhados antes e depois de pontos e hÃ­fens
				s/_\([.-]\)/\1/g
				s/\([.-]\)_/\1/g"
		)
		
		# Se der problema com a codificaÃ§Ã£o, Ã© o y/// do Sed anterior quem estoura
		if [ $? -ne 0 ]
		then
			echo "Ops. Problemas com a codificaÃ§Ã£o dos caracteres."
			echo "O arquivo original foi preservado: $arquivo"
			return
		fi
		
		# Nada mudou, entÃ£o o nome atual jÃ¡ certo
		[ "$antigo" = "$novo" ] && continue
		
		# Se jÃ¡ existir um arquivo/pasta com este nome, vai
		# colocando um nÃºmero no final, atÃ© o nome ser Ãºnico.
		if test -e "$caminho/$novo"
		then
			i=1
			while test -e "$caminho/$novo.$i"
			do
				i=$((i+1))
			done
			novo="$novo.$i"
		fi

		# Tudo certo, temos um nome novo e Ãºnico
				
		# Mostra o que serÃ¡ feito
		echo "$nao$arquivo -> $caminho/$novo"

		# E faz
		[ "$nao" ] || mv -- "$arquivo" "$caminho/$novo"
	done
}


# ----------------------------------------------------------------------------
# Renomeia arquivos do diretÃ³rio atual, arrumando a seqÃ¼Ãªncia numÃ©rica.
# Obs.: Ãtil para passar em arquivos de fotos baixadas de uma cÃ¢mera.
# OpÃ§Ãµes: -n  apenas mostra o que serÃ¡ feito, nÃ£o executa
#         -i  define a contagem inicial
#         -d  nÃºmero de dÃ­gitos para o nÃºmero
#         -p  prefixo padrÃ£o para os arquivos
# Uso: zznomefoto [-n] [-i N] [-d N] [-p TXT] arquivo(s)
# Ex.: zznomefoto -n *                        # tire o -n para renomear!
#      zznomefoto -n -p churrasco- *.JPG      # tire o -n para renomear!
#      zznomefoto -n -d 4 -i 500 *.JPG        # tire o -n para renomear!
# ----------------------------------------------------------------------------
zznomefoto ()
{
	zzzz -h nomefoto $1 && return
	
	local arquivo prefixo contagem extensao nome novo nao previa
	local i=1
	local digitos=3

	# OpÃ§Ãµes de linha de comando
	while [ "${1#-}" != "$1" ]
	do
		case "$1" in
			-p)
				prefixo="$2"
				shift; shift
			;;
			-i)
				i=$2
				shift; shift
			;;
			-d)
				digitos=$2
				shift; shift
			;;
			-n)
				nao='[-n] '
				shift
			;;
			*)
				break
			;;
		esac
	done

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso nomefoto; return; }

	if ! zztool testa_numero "$digitos"
	then
		echo "NÃºmero invÃ¡lido para a opÃ§Ã£o -d: $digitos"
		return
	fi
	if ! zztool testa_numero "$i"
	then
		echo "NÃºmero invÃ¡lido para a opÃ§Ã£o -i: $i"
		return
	fi
	
	# Para cada arquivo que o usuÃ¡rio informou...
	for arquivo in "$@"
	do
		# O arquivo existe?
		zztool arquivo_legivel "$arquivo" || continue
	
		# Componentes do nome novo
		contagem=$(printf "%0${digitos}d" $i)
		
		# Se tiver extensÃ£o, guarda para restaurar depois
		if zztool grep_var . "$arquivo"
		then
		 	extensao=".${arquivo##*.}"
		else
			extensao=
		fi

		# O nome comeÃ§a com o prefixo, se informado pelo usuÃ¡rio
		if [ "$prefixo" ]
		then
			nome=$prefixo
		else
			# Se nÃ£o tiver prefixo, usa o nome base do arquivo original,
			# sem extensÃ£o nem nÃºmeros no final (se houver).
			# Exemplo: DSC123.JPG -> DSC
			nome=$(echo "${arquivo%.*}" | sed 's/[0-9][0-9]*$//')
		fi
	
		# CompÃµe o nome novo e mostra na tela a mudanÃ§a
		novo="$nome$contagem$extensao"
		previa="$nao$arquivo -> $novo"
		
		if [ "$novo" = "$arquivo" ]
		then
			# Ops, o arquivo novo tem o mesmo nome do antigo
			echo "$previa" | sed "s/^\[-n\]/[-ERRO-]/"
		else
			echo "$previa"
		fi
		
		# Atualiza a contagem (Ah, sÃ©rio?)
		i=$((i+1))
		
		# Se nÃ£o tiver -n, vamos renomear o arquivo
		if ! [ "$nao" ]
		then
			# NÃ£o sobrescreve arquivos jÃ¡ existentes
			zztool arquivo_vago "$novo" || return

			# E finalmente, renomeia
			mv -- "$arquivo" "$novo"
		fi
	done
}


# ----------------------------------------------------------------------------
# Mostra a diferenÃ§a entre dois textos, palavra por palavra.
# Ãtil para conferir revisÃµes ortogrÃ¡ficas ou mudanÃ§as pequenas em frases.
# Obs.: Se tiver muitas *linhas* diferentes, use o comando diff.
# Uso: zzdiffpalavra arquivo1 arquivo2
# Ex.: zzdiffpalavra texto-orig.txt texto-novo.txt
# ----------------------------------------------------------------------------
zzdiffpalavra ()
{
	zzzz -h diffpalavra $1 && return
	
 	local tmp1="$ZZTMP.diffpalavra.1.$$"
	local tmp2="$ZZTMP.diffpalavra.2.$$"
	local n=$(printf '\a')

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ $# -ne 2 ] && { zztool uso diffpalavra; return; }

	# Verifica se os arquivos existem
	zztool arquivo_legivel "$1" || return
	zztool arquivo_legivel "$2" || return

	# Deixa uma palavra por linha e marca o inÃ­cio de parÃ¡grafos
	sed "s/^[[:blank:]]*$/$n$n/;" "$1" | tr ' ' '\n' > "$tmp1"
	sed "s/^[[:blank:]]*$/$n$n/;" "$2" | tr ' ' '\n' > "$tmp2"
	
	# Usa o diff para comparar as diferenÃ§as e formata a saÃ­da,
	# agrupando as palavras para facilitar a leitura do resultado
	diff -U 100 "$tmp1" "$tmp2" | 
		sed 's/^ /=/' |
		sed '
			# Script para agrupar linhas consecutivas de um mesmo tipo.
			# O tipo da linha Ã© o seu primeiro caractere. Ele nÃ£o pode
			# ser um espaÃ§o em branco.
			#     +um
			#     +dois
			#     .one
			#     .two
			# vira:
			#     +um dois
			#     .one two

			# Apaga os cabeÃ§alhos do diff
			1,3 d

			:join

			# Junta linhas consecutivas do mesmo tipo
			N

			# O espaÃ§o em branco Ã© o separador
			s/\n/ /

			# A linha atual Ã© do mesmo tipo da anterior?
			/^\(.\).* \1[^ ]*$/ {

				# Se for a Ãºltima linha, mostra tudo e sai
				$ s/ ./ /g
				$ q

				# Caso contrÃ¡rio continua juntando...
				b join
			}
			# Opa, linha diferente (antiga \n antiga \n ... \n nova)

			# Salva uma cÃ³pia completa
			h

			# Apaga a Ãºltima linha (nova) e mostra as anteriores
			s/\(.*\) [^ ]*$/\1/
			s/ ./ /g
			p

			# Volta a cÃ³pia, apaga linhas antigas e comeÃ§a de novo
			g
			s/.* //
			$ !b join
			# Mas se for a Ãºltima linha, acabamos por aqui' |
		sed 's/^=/ /' |
		
		# Restaura os parÃ¡grafos
 		tr "$n" '\n' |
		
		# Podemos mostrar cores?
		if [ "$ZZCOR" = 1 ]
		then
			# Pinta as linhas antigas de vermelho e as novas de azul
			esc=$(printf '\033')
			sed "
				s/^-.*/$esc[31;1m&$esc[m/
				s/^+.*/$esc[36;1m&$esc[m/"
		else
			# Sem cores? Que chato. SÃ³ mostra entÃ£o.
			cat -
		fi
			
	rm -f "$tmp1" "$tmp2"
}


# ----------------------------------------------------------------------------
# Acha as funÃ§Ãµes de uma biblioteca da linguagem C (arquivos .h).
# Obs.: O diretÃ³rio padrÃ£o de procura Ã© o /usr/include.
# Uso: zzcinclude nome-biblioteca
# Ex.: zzcinclude stdio
#      zzcinclude /minha/rota/alternativa/stdio.h
# ----------------------------------------------------------------------------
zzcinclude ()
{
	zzzz -h cinclude $1 && return
	
	local arquivo="$1"
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso cinclude; return; }

	# Se nÃ£o comeÃ§ar com / (caminho relativo), coloca path padrÃ£o
	[ "${arquivo#/}" = "$arquivo" ] && arquivo="/usr/include/$arquivo.h"
	
	# Verifica se o arquivo existe
	zztool arquivo_legivel "$arquivo" || return
		
	# SaÃ­da ordenada, com um Sed mÃ¡gico para limpar a saÃ­da do cpp
	cpp -E "$arquivo" |
		sed '
			/^ *$/d
			/^# /d
			/^typedef/d
			/^[^a-z]/d
			s/ *(.*//
			s/.* \*\{0,1\}//' |
		sort
}


# ----------------------------------------------------------------------------
# Acha os maiores arquivos/diretÃ³rios do diretÃ³rio atual (ou outros).
# OpÃ§Ãµes: -r  busca recursiva nos subdiretÃ³rios
#         -f  busca somente os arquivos e nÃ£o diretÃ³rios
#         -n  nÃºmero de resultados (o padrÃ£o Ã© 10)
# Uso: zzmaiores [-r] [-f] [-n <nÃºmero>] [dir1 dir2 ...]
# Ex.: zzmaiores
#      zzmaiores /etc /tmp
#      zzmaiores -r -n 5 ~
# ----------------------------------------------------------------------------
zzmaiores ()
{
	zzzz -h maiores $1 && return

	local pastas recursivo modo
	local limite=10

	# OpÃ§Ãµes de linha de comando
	while [ "${1#-}" != "$1" ]
	do
		case "$1" in
			-n)
				limite=$2
				shift; shift
			;;
			-f)
				modo='f'
				shift
				# AtÃ© queria fazer um -d tambÃ©m para diretÃ³rios somente,
				# mas o du sempre mostra os arquivos quando estÃ¡ recursivo
				# e o find nÃ£o mostra o tamanho total dos diretÃ³rios...
			;;
			-r)
				recursivo=1
				shift
			;;
			*)
				break
			;;
		esac
	done

	if [ "$modo" = 'f' ]
	then
		# UsuÃ¡rio sÃ³ quer ver os arquivos e nÃ£o diretÃ³rios.
		# Como o 'du' nÃ£o tem uma opÃ§Ã£o para isso, usaremos o 'find'.
	
		# Se forem vÃ¡rias pastas, compÃµe a lista glob: {um,dois,trÃªs}
		# Isso porque o find nÃ£o aceita mÃºltiplos diretÃ³rios sem glob.
		# Caso contrÃ¡rio tenta $1 ou usa a pasta corrente "."
		if [ "$2" ]
		then
			pastas=$(echo {$*} | tr -s ' ' ',')
		else
			pastas=${1:-.}
			[ "$pastas" = '*' ] && pastas='.'
		fi
	
		tab=$(echo -e '\t')
		[ "$recursivo" ] && recursivo= || recursivo='-maxdepth 1'
		
		resultado=$(
			find $pastas $recursivo -type f -ls |
			 	tr -s ' ' |
			 	cut -d' ' -f7,11- |
				sed "s/ /$tab/" |
			 	sort -nr |
			 	sed "$limite q"
		)
	else
		# Tentei de vÃ¡rias maneiras juntar o glob com o $@
		# para que funcionasse com o ponto e sem argumentos,
		# mas no fim Ã© mais fÃ¡cil chamar a funÃ§Ã£o de novo...
		pastas="$@"
		if [ ! "$pastas" -o "$pastas" = '.' ]
		then
			zzmaiores ${recursivo:+-r} -n $limite * .[^.]*
			return
			
		fi

		# O du sempre mostra arquivos e diretÃ³rios, bacana
		# Basta definir se vai ser recursivo (-a) ou nÃ£o (-s)
		[ "$recursivo" ] && recursivo='-a' || recursivo='-s'
		
		# Estou escondendo o erro para caso o * ou o .* nÃ£o expandam
		# Bash2: nullglob, dotglob
		resultado=$(
			du $recursivo $pastas 2>/dev/null |
				sort -nr |
				sed "$limite q"
		)
	fi
	# TODO Ã© K (nem Ã©, sÃ³ se usar -k -- conferir no SF) se vier do du e bytes se do find
	echo "$resultado"
	# | while read tamanho arquivo
	# do
	# 		echo -e "$(zzbyte $tamanho)\t$arquivo"
	# done
}


# ----------------------------------------------------------------------------
# Conta o nÃºmero de vezes que uma palavra aparece num arquivo.
# Obs.: Ã diferente do grep -c, que nÃ£o conta vÃ¡rias palavras na mesma linha.
# OpÃ§Ãµes: -i  ignora a diferenÃ§a de maiÃºsculas/minÃºsculas
#         -p  busca parcial, conta trechos de palavras
# Uso: zzcontapalavra [-i|-p] palavra arquivo(s)
# Ex.: zzcontapalavra root /etc/passwd
#      zzcontapalavra -i -p a /etc/passwd      # Compare com grep -ci a
# ----------------------------------------------------------------------------
zzcontapalavra ()
{
	zzzz -h contapalavra $1 && return

	local padrao ignora
	local inteira=1
	
	# OpÃ§Ãµes de linha de comando
	while [ "${1#-}" != "$1" ]
	do
		case "$1" in
			-p) inteira=  ;;
			-i) ignora=1  ;;
			 *) break     ;;
		esac
		shift
	done

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso contapalavra; return; }
	
	padrao=$1
	shift
	
	# Contorna a limitaÃ§Ã£o do grep -c pesquisando pela palavra
	# e quebrando o resultado em uma palavra por linha (tr).
	# EntÃ£o pode-se usar o grep -c para contar.
	grep -h ${ignora:+-i} ${inteira:+-w} -- "$padrao" "$@" |
		tr '\t./ -,:-@[-_{-~' '\n' |
		grep -c ${ignora:+-i} ${inteira:+-w} -- "$padrao"
}


# ----------------------------------------------------------------------------
# Mostra uma linha de um texto, aleatÃ³ria ou informada pelo nÃºmero.
# Obs.: Se passado um argumento, restringe o sorteio Ã s linhas com o padrÃ£o.
# Uso: zzlinha [nÃºmero | -t texto] [arquivo(s)]
# Ex.: zzlinha /etc/passwd           # mostra uma linha qualquer, aleatÃ³ria
#      zzlinha 9 /etc/passwd         # mostra a linha 9 do arquivo
#      zzlinha -t root /etc/passwd   # mostra uma das linhas com "root"
#      cat /etc/passwd | zzlinha     # o arquivo pode vir da entrada padrÃ£o
# ----------------------------------------------------------------------------
# TODO nÃºmeros negativos (conta Ã  partir do fim)
zzlinha ()
{
	zzzz -h linha $1 && return

	local arquivo n padrao resultado num_linhas

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-t' ]
	then
		padrao="$2"
		shift; shift
	fi
	
	# Talvez o $1 Ã© o nÃºmero da linha desejada?
	if zztool testa_numero "$1"
	then
		n=$1
		shift
	fi

	if [ "$n" ]
	then
		# Se foi informado um nÃºmero, mostra essa linha.
		# Nota: Suporte a mÃºltiplos arquivos e entrada padrÃ£o (STDIN)
		for arquivo in "${@:--}"
		do
			sed -n ${n}p "$arquivo"
		done
	else
		# Se foi informado um padrÃ£o (ou nenhum argumento),
		# primeiro grepa as linhas, depois mostra uma linha
		# aleatÃ³ria deste resultado.
		# Nota: Suporte a mÃºltiplos arquivos e entrada padrÃ£o (STDIN)
		resultado=$(grep -h -i -- "${padrao:-.}" "${@:--}")
		num_linhas=$(echo "$resultado" | sed -n '$=')
		n=$(( (RANDOM % num_linhas) + 1))
		[ $n -eq 0 ] && n=1
		echo "$resultado" | sed -n ${n}p
	fi
}



# ----------------------------------------------------------------------------
# #### C Ã L C U L O
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# Calculadora.
# Os operadores principais sÃ£o + - / * ^ %, veja outros em "man bc". 
# Obs.: NÃºmeros fracionados podem vir com vÃ­rgulas ou pontos: 1,5 ou 1.5.
# Uso: zzcalcula nÃºmero operaÃ§Ã£o nÃºmero
# Ex.: zzcalcula 2,20 + 3.30          # vÃ­rgulas ou pontos, tanto faz
#      zzcalcula '2^2*(4-1)'          # 2 ao quadrado vezes 4 menos 1
#      echo 2 + 2 | zzcalcula         # lendo da entrada padrÃ£o (STDIN)
# ----------------------------------------------------------------------------
zzcalcula ()
{
	zzzz -h calcula $1 && return
	
	local parametros=$(zztool multi_stdin $*)

	# Entrada de nÃºmeros com vÃ­rgulas ou pontos, saÃ­da sempre com vÃ­rgulas
	echo "scale=2;$parametros" | sed y/,/./ | bc | sed y/./,/
}


# ----------------------------------------------------------------------------
# Faz cÃ¡lculos com datas e/ou converte data->num e num->data.
# Que dia vai ser daqui 45 dias? Quantos dias hÃ¡ entre duas datas? zzdata!
# Quando chamada com apenas um parÃ¢metro funciona como conversor de data
# para nÃºmero inteiro (N dias passados desde Epoch) e vice-versa.
# Obs.: Leva em conta os anos bissextos     (Epoch = 01/01/1970, editÃ¡vel)
# Uso: zzdata data|num [+|- data|num]
# Ex.: zzdata 22/12/1999 + 69
#      zzdata hoje - 5
#      zzdata 01/03/2000 - 11/11/1999
#      zzdata hoje - dd/mm/aaaa         <---- use sua data de nascimento
# ----------------------------------------------------------------------------
zzdata ()
{
	zzzz -h data $1 && return

	local yyyy mm dd dias_ano data dias i n y op
	local epoch=1970
	local primeira_data=1
	local dias_mes='31 28 31 30 31 30 31 31 30 31 30 31'
	local data1=$1
	local operacao=$2
	local data2=$3
	local n1=$data1
	local n2=$data2

	# ReferÃªncias para ano bissexto:
	#
	# A year is a leap year if it is evenly divisible by 4
	# ...but not if it's evenly divisible by 100
	# ...unless it's also evenly divisible by 400
	# http://timeanddate.com
	# http://www.delorie.com/gnu/docs/gcal/gcal_34.html
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ $# -eq 3 -o $# -eq 1 ] || { zztool uso data; return; }

	# Esse bloco gigante define $n1 e $n2 baseado nas datas $data1 e $data2.
	# A data Ã© transformada em um nÃºmero inteiro (dias desde $epoch).
	# Exemplo: 27/07/2007 -> 13721
	# Este Ã© numero usado para fazer os cÃ¡lculos.
	for data in $data1 $data2
	do
		dias=0 # Guarda o total que irÃ¡ para $n1 e $n2
		
		# Atalhos Ãºteis para o dia atual
		if [ "$data" = 'hoje' -o "$data" = 'today' ]
		then
			# Qual a data de hoje?
			data=$(date +%d/%m/%Y)
			[ "$primeira_data" ] && data1=$data || data2=$data
		else
			# Valida o formato da data
			# TODO Muito fraquinho, usar regex (zztool)
			if [ "${data##*[^0-9/]}" != "$data" ]
			then
				echo "Data invÃ¡lida '$data'"
				return
			fi
		fi
		
		# Se tem /, entÃ£o Ã© uma data e deve ser transformado em nÃºmero
		if zztool grep_var / "$data"
		then
			n=1
			y=$epoch
			yyyy=${data##*/}
			mm=${data#*/}
			mm=${mm%/*}
			dd=${data%%/*}

			# Retira o zero dos dias e meses menores que 10
			mm=${mm#0}
			dd=${dd#0}

			# Define qual serÃ¡ a operaÃ§Ã£o: adiÃ§Ã£o ou subtraÃ§Ã£o
			op=+
			[ $yyyy -lt $epoch ] && op=-
			
			# Ano -> dias
			while :
			do
				# Sim, os anos bissextos sÃ£o levados em conta!
				dias_ano=365
				[ $((y%4)) -eq 0 ] && [ $((y%100)) -ne 0 ] || [ $((y%400)) -eq 0 ] && dias_ano=366
				
				# Vai somando (ou subtraindo) atÃ© chegar no ano corrente
				[ $y -eq $yyyy ] && break
				dias=$((dias $op dias_ano))
				y=$((y $op 1))
			done
			
			# Meses -> dias
			for i in $dias_mes
			do
				[ $n -eq $mm ] && break
				n=$((n+1))
				
				# Fevereiro de ano bissexto tem 29 dias
				[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29
				
				dias=$((dias+$i))
			done
			
			# Somando os dias da data aos anos+meses jÃ¡ contados (-1)
			dias=$((dias+dd-1))
			
			[ "$primeira_data" ] && n1=$dias || n2=$dias
		fi
		primeira_data=
	done
	
	# Agora que ambas as datas sÃ£o nÃºmeros inteiros, a conta Ã© feita
	dias=$(($n1 $operacao $n2))
	
	# Se as duas datas foram informadas como dd/mm/aaaa,
	# o resultado Ã© o prÃ³prio nÃºmero de dias, entÃ£o terminamos.
	if [ "${data1##??/*}" = "${data2##??/*}" ]
	then
		echo $dias
		return
	fi
	
	# Como nÃ£o caÃ­mos no IF anterior, entÃ£o o resultado serÃ¡ uma data.
	# Ã preciso converter o nÃºmero inteiro para dd/mm/aaaa.
	
	y=$epoch
	mm=1
	dd=$((dias+1))
	
	# Dias -> Ano
	while :
	do
		# Novamente, o ano bissexto Ã© levado em conta
		dias_ano=365
		[ $((y%4)) -eq 0 ] && [ $((y%100)) -ne 0 ] || [ $((y%400)) -eq 0 ] && dias_ano=366
		
		# Vai descontando os dias de cada ano para saber quantos anos cabem
		[ $dd -le $dias_ano ] && break
		dd=$((dd-dias_ano))
		y=$((y+1))
	done
	yyyy=$y
	
	# Dias -> mÃªs
	for i in $dias_mes
	do
		# Fevereiro de ano bissexto tem 29 dias
		[ $dias_ano -eq 366 -a $i -eq 28 ] && i=29
	
		# Calcula quantos meses cabem nos dias que sobraram
		[ $dd -le $i ] && break
		dd=$((dd-i))
		mm=$((mm+1))
	done
	
	# Restaura o zero dos meses menores que 10
	[ $dd -le 9 ] && dd=0$dd
	[ $mm -le 9 ] && mm=0$mm
	
	# E finalmente mostra o resultado em formato de data
	echo $dd/$mm/$yyyy
}


# ----------------------------------------------------------------------------
# Faz cÃ¡lculos com horÃ¡rios.
# A opÃ§Ã£o -r torna o cÃ¡lculo relativo Ã  primeira data, por exemplo:
#   02:00 - 03:30 = -01:30 (sem -r) e 22:30 (com -r)
# Uso: zzhora [-r] hh:mm [+|- hh:mm]
# Ex.: zzhora 8:30 + 17:25        # preciso somar duas horas!
#      zzhora 12:00 - agora       # quando falta para o almoÃ§o?
#      zzhora -12:00 + -5:00      # horas negativas!!!
#      zzhora 1000                # quanto Ã© 1000 minutos?
#      zzhora -r 5:30 - 8:00      # que horas ir dormir para acordar Ã s 5:30?
#      zzhora -r agora + 57:00    # e daqui 57 horas, serÃ¡ quando?
# ----------------------------------------------------------------------------
zzhora ()
{
	zzzz -h hora $1 && return

	local hhmm1 hhmm2 operacao
	local hh1 mm1 hh2 mm2 n1 n2 resultado negativo
	local horas minutos dias horas_do_dia hh mm hh_dia extra
	local relativo=0

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-r' ]
	then
		relativo=1
		shift
	fi
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso hora; return; }
	
	# Dados informados pelo usuÃ¡rio (com valores padrÃ£o)
	hhmm1="$1"
	operacao="${2:-+}"
	hhmm2="${3:-00}"

	# Somente adiÃ§Ã£o e subtraÃ§Ã£o sÃ£o permitidas
	if [ "${operacao#[+-]}" ]
	then
	 	echo "OperaÃ§Ã£o InvÃ¡lida: $operacao"
		return
	fi
	
	# Atalhos bacanas para a hora atual
	[ "$hhmm1" = 'agora' -o "$hhmm1" = 'now' ] && hhmm1=$(date +%H:%M)
	[ "$hhmm2" = 'agora' -o "$hhmm2" = 'now' ] && hhmm2=$(date +%H:%M)
	
	# Se as horas nÃ£o foram informadas, coloca 00
	[ "${hhmm1#*:}" = "$hhmm1" ] && hhmm1=00:$hhmm1
	[ "${hhmm2#*:}" = "$hhmm2" ] && hhmm2=00:$hhmm2
	
	# Extrai horas e minutos para variÃ¡veis separadas
	hh1=${hhmm1%:*}
	mm1=${hhmm1#*:}
	hh2=${hhmm2%:*}
	mm2=${hhmm2#*:}
	
	# Retira o zero das horas e minutos menores que 10
	hh1=${hh1#0}
	mm1=${mm1#0}
	hh2=${hh2#0}
	mm2=${mm2#0}
	
	# Os cÃ¡lculos sÃ£o feitos utilizando apenas minutos.
	# EntÃ£o Ã© preciso converter as horas:minutos para somente minutos.
	n1=$((hh1*60+mm1))
	n2=$((hh2*60+mm2))
	
	# Tudo certo, hora de fazer o cÃ¡lculo
	resultado=$(($n1 $operacao $n2))
	
	# Resultado negativo, seta a flag e remove o sinal de menos "-"
	if [ $resultado -lt 0 ]
	then
	 	negativo=-
		resultado=${resultado#-}
	fi
	
	# Agora Ã© preciso converter o resultado para o formato hh:mm

	horas=$((resultado/60))
	minutos=$((resultado%60))
	dias=$((horas/24))
	horas_do_dia=$((horas%24))
	
	# Restaura o zero dos minutos/horas menores que 10
	hh=$horas
	mm=$minutos
	hh_dia=$horas_do_dia
	[ $hh -le 9 ] && hh=0$hh
	[ $mm -le 9 ] && mm=0$mm
	[ $hh_dia -le 9 ] && hh_dia=0$hh_dia
	
	# Decide como mostrar o resultado para o usuÃ¡rio.
	#
	# Relativo:
	#   $ zzhora -r 10:00 + 48:00
	#   10:00 (2 dias)
	#
	# Normal:
	#   $ zzhora 10:00 + 48:00
	#   58:00 (2d 10h 0m)
	#
	if [ $relativo -eq 1 ]
	then
	
		# Relativo
	
		# Somente em resultados negativos o relativo Ã© Ãºtil.
		# Para valores positivos nÃ£o Ã© preciso fazer nada.
		if [ "$negativo" ]
		then
			# Para o resultado negativo Ã© preciso refazer algumas contas
			minutos=$(( (60-minutos) % 60))
			dias=$((horas/24 + (minutos>0) ))
			hh_dia=$(( (24 - horas_do_dia - (minutos>0)) % 24))
			mm=$minutos

			# Zeros para dias e minutos menores que 10
			[ $mm -le 9 ] && mm=0$mm
			[ $hh_dia -le 9 ] && hh_dia=0$hh_dia
		fi
		
		# "Hoje", "amanhÃ£" e "ontem" sÃ£o simpÃ¡ticos no resultado
		case $negativo$dias in
			1)
			 	extra='amanhÃ£'
			;;
			-1)
			 	extra='ontem'
			;;
			0|-0)
			 	extra='hoje'
			;;
			*)
			 	extra="$negativo$dias dias"
			;;
		esac

		echo "$hh_dia:$mm ($extra)"
	else
	
		# Normal
		
		echo "$negativo$hh:$mm (${dias}d ${horas_do_dia}h ${minutos}m)"
	fi
}


# ----------------------------------------------------------------------------
# Faz vÃ¡rias conversÃµes como: caracteres, temperatura e distÃ¢ncia.
#          cf = (C)elsius      para (F)ahrenheit
#          fc = (F)ahrenheit   para (C)elsius
#          ck = (C)elsius      para (K)elvin
#          kc = (K)elvin       para (C)elsius
#          fk = (F)ahrenheit   para (K)elvin
#          kf = (K)elvin       para (F)ahrenheit
#          km = (K)QuilÃ´metros para (M)ilhas
#          mk = (M)ilhas       para (K)QuilÃ´metros
#          db = (D)ecimal      para (B)inÃ¡rio
#          bd = (B)inÃ¡rio      para (D)ecimal
#          cd = (C)aractere    para (D)ecimal
#          dc = (D)ecimal      para (C)aractere
#          dh = (D)ecimal      para (H)exadecimal
#          hd = (H)exadecimal  para (D)ecimal
# Uso: zzconverte <cf|fc|ck|kc|fk|kf|mk|km|db|bd|cd|dh|hd> nÃºmero
# Ex.: zzconverte cf 5
#      zzconverte dc 65
#      zzconverte db 32
# ----------------------------------------------------------------------------
zzconverte ()
{
	zzzz -h converte $1 && return

	local s2='scale=2'
	local operacao=$1
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$2" ] || { zztool uso converte; return; }
	
	shift
	while [ "$1" ]
	do
		case "$operacao" in
			cf)
				echo "$1 C = $(echo "$s2;($1*9/5)+32"     | bc) F"
			;;
			fc)
		 		echo "$1 F = $(echo "$s2;($1-32)*5/9"     | bc) C"
			;;
			ck)
				echo "$1 C = $(echo "$s2;$1+273.15"       | bc) K"
			;;
			kc)
		 		echo "$1 K = $(echo "$s2;$1-273.15"       | bc) C"
			;;
			kf)
			 	echo "$1 K = $(echo "$s2;($1*1.8)-459.67" | bc) F"
			;;
			fk)
				echo "$1 F = $(echo "$s2;($1+459.67)/1.8" | bc) K"
			;;
			km)
			 	echo "$1 km = $(echo "$s2;$1*0.6214"      | bc) milhas"
			;;
			mk)
			 	echo "$1 milhas = $(echo "$s2;$1*1.609"   | bc) km"
			;;
			db)
			 	echo "obase=2;$1" | bc -l
			;;
			bd)
			 	echo "$((2#$1))"
			;;
			cd)
			 	echo -n "$1" |
			 		od -d |
			 		tr -s '\t ' ' ' |
					cut -d' ' -f2- |
					sed 's/ *$// ; 1q'
			;;
			dc)
			 	awk "BEGIN { printf(\"%c\n\", $1) }"
			
				# XXX " TextMate syntax gotcha (nÃ£o remover)
			;;
			dh)
				printf '%X\n' "$1"
			;;
			hd)
				printf '%d\n' "0x$1"
			;;
		esac
		shift
	done
}


# ----------------------------------------------------------------------------
# Gera um CPF vÃ¡lido aleatÃ³rio ou valida um CPF informado.
# Obs.: O CPF informado pode estar formatado (pontos e hÃ­fen) ou nÃ£o.
# Uso: zzcpf [cpf]
# Ex.: zzcpf 123.456.789-09          # valida o CPF
#      zzcpf 12345678909             # com ou sem formatadores
#      zzcpf                         # gera um CPF vÃ¡lido
# ----------------------------------------------------------------------------
zzcpf ()
{
	zzzz -h cpf $1 && return

	local i n somatoria digito1 digito2 cpf base

	# Remove pontuaÃ§Ã£o do CPF informado, deixando apenas nÃºmeros
	cpf="$(echo $* | tr -d -c 0-9)"
	
	# Extrai os nÃºmeros da base do CPF:
	# Os 9 primeiros, sem os dois dÃ­gitos verificadores.
	# Esses dois dÃ­gitos serÃ£o calculados adiante.
	if [ "$cpf" ]
	then
		# Faltou ou sobrou algum nÃºmero...
		if [ ${#cpf} -ne 11 ]
		then
			echo 'CPF invÃ¡lido (deve ter 11 dÃ­gitos)'
			return
		fi
		
		# Apaga os dois Ãºltimo dÃ­gitos
		base=${cpf%??}
	else
		# NÃ£o foi informado nenhum CPF, vamos gerar um escolhendo
		# nove dÃ­gitos aleatoriamente para formar a base
		while [ ${#cpf} -lt 9 ]
		do
			cpf="$cpf$((RANDOM % 9))"
		done
		base=$cpf
	fi
	
	# Truque para cada dÃ­gito da base ser guardado em $1, $2, $3, ...
	set - $(echo $base | sed 's/./& /g')

	# ExplicaÃ§Ã£o do algoritmo de geraÃ§Ã£o/validaÃ§Ã£o do CPF:
	#
	# Os primeiros 9 dÃ­gitos sÃ£o livres, vocÃª pode digitar quaisquer
	# nÃºmeros, nÃ£o hÃ¡ seqÃ¼Ãªncia. O que importa Ã© que os dois Ãºltimos
	# dÃ­gitos, chamados verificadores, estejam corretos.
	#
	# Estes dÃ­gitos sÃ£o calculados em cima dos 9 primeiros, seguindo
	# a seguinte fÃ³rmula:
	#
	# 1) Aplica a multiplicaÃ§Ã£o de cada dÃ­gito na mÃ¡scara de nÃºmeros
	#    que Ã© de 10 a 2 para o primeiro dÃ­gito e de 11 a 3 para o segundo.
	# 2) Depois tira o mÃ³dulo de 11 do somatÃ³rio dos resultados.
	# 3) Diminui isso de 11 e se der 10 ou mais vira zero.
	# 4) Pronto, achou o primeiro dÃ­gito verificador.
	#
	# MÃ¡scara   : 10    9    8    7    6    5    4    3    2
	# CPF       :  2    2    5    4    3    7    1    0    1
	# Multiplica: 20 + 18 + 40 + 28 + 18 + 35 +  4 +  0 +  2 = SomatÃ³ria
	#
	# Para o segundo Ã© praticamente igual, porÃ©m muda a mÃ¡scara (11 - 3)
	# e ao somatÃ³rio Ã© adicionado o dÃ­gito 1 multiplicado por 2.
	
	### CÃ¡lculo do dÃ­gito verificador 1
	# Passo 1
	somatoria=0
	for i in 10 9 8 7 6 5 4 3 2 # mÃ¡scara
	do
		# Cada um dos dÃ­gitos da base ($n) Ã© multiplicado pelo
		# seu nÃºmero correspondente da mÃ¡scara ($i) e adicionado
		# na somatÃ³ria.
		n=$1
		somatoria=$((somatoria + (i * n)))
		shift
	done
	# Passo 2
	digito1=$((11 - (somatoria % 11)))
	# Passo 3
	[ $digito1 -ge 10 ] && digito1=0
	
	### CÃ¡lculo do dÃ­gito verificador 2
	# Tudo igual ao anterior, primeiro setando $1, $2, $3, etc e
	# depois fazendo os cÃ¡lculos jÃ¡ explicados.
	#
	set - $(echo $base | sed 's/./& /g')
	# Passo 1
	somatoria=0
	for i in 11 10 9 8 7 6 5 4 3
	do
		n=$1
		somatoria=$((somatoria + (i * n)))
		shift
	done
	# Passo 1 e meio (o dobro do verificador 1 entra na somatÃ³ria)
	somatoria=$((somatoria + digito1 * 2))
	# Passo 2
	digito2=$((11 - (somatoria % 11)))
	# Passo 3
	[ $digito2 -ge 10 ] && digito2=0
	
	# Mostra ou valida
	if [ ${#cpf} -eq 9 ]
	then
		# Esse CPF foi gerado aleatoriamente pela funÃ§Ã£o.
		# Apenas adiciona os dÃ­gitos verificadores e mostra na tela.
		echo $cpf$digito1$digito2 |
		 	sed 's/\(...\)\(...\)\(...\)/\1.\2.\3-/' # nnn.nnn.nnn-nn
	else
		# Esse CPF foi informado pelo usuÃ¡rio.
		# Compara os verificadores informados com os calculados.
		if [ "${cpf#?????????}" = "$digito1$digito2" ]
		then
			echo CPF vÃ¡lido
		else
			# Boa aÃ§Ã£o do dia: mostrar quais os verificadores corretos
			echo "CPF invÃ¡lido (-$digito1$digito2)"
		fi
	fi
}


# ----------------------------------------------------------------------------
# Gera um CNPJ vÃ¡lido aleatÃ³rio ou valida um CNPJ informado.
# Obs.: O CNPJ informado pode estar formatado (pontos e hÃ­fen) ou nÃ£o.
# Uso: zzcnpj [cnpj]
# Ex.: zzcnpj 12.345.678/0001-95      # valida o CNPJ
#      zzcnpj 12345678000195          # com ou sem formatadores
#      zzcnpj                         # gera um CNPJ vÃ¡lido
# ----------------------------------------------------------------------------
zzcnpj ()
{
	zzzz -h cnpj $1 && return

	local i n somatoria digito1 digito2 cnpj base

	# AtenÃ§Ã£o:
	# Essa funÃ§Ã£o Ã© irmÃ£-quase-gÃªmea da zzcpf, que estÃ¡ bem
	# documentada, entÃ£o nÃ£o vou repetir aqui os comentÃ¡rios.
	#
	# O cÃ¡lculo dos dÃ­gitos verificadores tambÃ©m Ã© idÃªntico,
	# apenas com uma mÃ¡scara numÃ©rica maior, devido Ã  quantidade
	# maior de dÃ­gitos do CNPJ em relaÃ§Ã£o ao CPF.

	cnpj="$(echo $* | tr -d -c 0-9)"
	
	if [ "$cnpj" ]
	then
		# CNPJ do usuÃ¡rio

		if [ ${#cnpj} -ne 14 ]
		then
			echo 'CNPJ invÃ¡lido (deve ter 14 dÃ­gitos)'
			return
		fi

		base=${cnpj%??}
	else
		# CNPJ gerado aleatoriamente

		while [ ${#cnpj} -lt 8 ]
		do
			cnpj="$cnpj$((RANDOM % 9))"
		done

		cnpj="${cnpj}0001"
		base=$cnpj
	fi

	# CÃ¡lculo do dÃ­gito verificador 1

	set - $(echo $base | sed 's/./& /g')

	somatoria=0
	for i in 5 4 3 2 9 8 7 6 5 4 3 2
	do
		n=$1
		somatoria=$((somatoria + (i * n)))
		shift
	done

	digito1=$((11 - (somatoria % 11)))
	[ $digito1 -ge 10 ] && digito1=0

	# CÃ¡lculo do dÃ­gito verificador 2

	set - $(echo $base | sed 's/./& /g')
	
	somatoria=0
	for i in 6 5 4 3 2 9 8 7 6 5 4 3 2
	do
		n=$1
		somatoria=$((somatoria + (i * n)))
		shift
	done
	somatoria=$((somatoria + digito1 * 2))

	digito2=$((11 - (somatoria % 11)))
	[ $digito2 -ge 10 ] && digito2=0

	# Mostra ou valida o CNPJ
	if [ ${#cnpj} -eq 12 ]
	then
		echo $cnpj$digito1$digito2 |
		 	sed 's|\(..\)\(...\)\(...\)\(....\)|\1.\2.\3/\4-|'
	else
		if [ "${cnpj#????????????}" = "$digito1$digito2" ]
		then
			echo CNPJ vÃ¡lido
		else
			echo "CNPJ invÃ¡lido (-$digito1$digito2)"
		fi
	fi
}


# ----------------------------------------------------------------------------
# Calcula os endereÃ§os de rede e broadcast Ã  partir do IP e mÃ¡scara da rede.
# Obs.: Se nÃ£o for especificado a mÃ¡scara, Ã© assumido a 255.255.255.0.
# Uso: zzcalculaip ip [netmask]
# Ex.: zzcalculaip 127.0.0.1 24
#      zzcalculaip 10.0.0.0/8
#      zzcalculaip 192.168.10.0 255.255.255.240
#      zzcalculaip 10.10.10.0
# ----------------------------------------------------------------------------
zzcalculaip ()
{
	zzzz -h calculaip $1 && return

	local endereco mascara rede broadcast
	local mascara_binario mascara_decimal mascara_ip
	local i ip1 ip2 ip3 ip4 nm1 nm2 nm3 nm4 componente

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ $# -eq 0 -o $# -gt 2 ] && { zztool uso calculaip; return; }

	# ObtÃ©m a mÃ¡scara da rede (netmask)
	if zztool grep_var / "$1"
	then
		endereco=${1%/*}
		mascara="${1#*/}"
	else
		endereco=$1
		mascara=${2:-24}
	fi

	# VerificaÃ§Ãµes bÃ¡sicas
	if ! zztool testa_ip $endereco
	then
		echo "IP invÃ¡lido: $endereco"
		return
	fi
	if ! (zztool testa_ip $mascara || (
	      zztool testa_numero $mascara && test $mascara -le 32))
	then
		echo "MÃ¡scara invÃ¡lida: $mascara"
		return
	fi

	# Guarda os componentes da mÃ¡scara em $1, $2, ...
	# Ou Ã© um ou quatro componentes: 24 ou 255.255.255.0
	set - $(echo $mascara | tr . ' ')

	# MÃ¡scara no formato NN
	if [ $# -eq 1 ]
	then
		# Converte de decimal para binÃ¡rio
		# Coloca N nÃºmeros 1 grudados '1111111' (N=$1)
		# e completa com zeros Ã  direita atÃ© 32, com pontos:
		# $1=12 vira 11111111.11110000.00000000.00000000
		mascara=$(printf "%$1s" 1 | tr ' ' 1)
		mascara=$(
			printf '%-32s' $mascara |
			tr ' ' 0 |
			sed 's/./&./24 ; s/./&./16 ; s/./&./8'
		)
	fi
	
	# ConversÃ£o de decimal para binÃ¡rio nos componentes do IP e netmask
	for i in 1 2 3 4
	do
		componente=$(echo $endereco | cut -d'.' -f $i)
		eval ip$i=$(printf '%08d' $(zzconverte db $componente))

		componente=$(echo $mascara | cut -d'.' -f $i)
		if [ "$2" ]
		then
			eval nm$i=$(printf '%08d' $(zzconverte db $componente))
		else
			eval nm$i=$componente
		fi
	done
	
	# Uma verificaÃ§Ã£o na mÃ¡scara depois das conversÃµes
	mascara_binario=$nm1$nm2$nm3$nm4
	if ! (zztool testa_binario $mascara_binario &&
	      test ${#mascara_binario} -eq 32)
	then
		echo 'MÃ¡scara invÃ¡lida'
		return
	fi
	
	mascara_decimal=$(echo $mascara_binario | tr -d 0)
	mascara_decimal=${#mascara_decimal}
	mascara_ip="$((2#$nm1)).$((2#$nm2)).$((2#$nm3)).$((2#$nm4))"
	
	echo "End. IP  : $endereco"
	echo "Mascara  : $mascara_ip = $mascara_decimal"
	
	rede=$(( ((2#$ip1$ip2$ip3$ip4)) & ((2#$nm1$nm2$nm3$nm4)) ))
	i=$(echo $nm1$nm2$nm3$nm4 | tr 01 10)
	broadcast=$(($rede | ((2#$i)) ))
	
	# CÃ¡lculo do endereÃ§o de rede
	endereco=""
	for i in 1 2 3 4
	do
		ip1=$((rede & 255))
		rede=$((rede >> 8))
		endereco="$ip1.$endereco"
	done
	
	echo "Rede     : ${endereco%.} / $mascara_decimal"

	# CÃ¡lculo do endereÃ§o de broadcast
	endereco=''
	for i in 1 2 3 4
	do
		ip1=$((broadcast & 255))
		broadcast=$((broadcast >> 8))
		endereco="$ip1.$endereco"
	done
	echo "Broadcast: ${endereco%.}"
}



#-----------8<---------- Daqui pra baixo, funÃ§Ãµes que fazem busca na Internet.
#----------------------- Podem parar de funcionar se os sites mudarem.


# ----------------------------------------------------------------------------
# #### C O N S U L T A S                                         (Internet)
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# http://br.invertia.com
# Busca a cotaÃ§Ã£o do dia do dÃ³lar (comercial, paralelo e turismo).
# Obs.: As cotaÃ§Ãµes sÃ£o atualizadas de 10 em 10 minutos.
# Uso: zzdolar
# ----------------------------------------------------------------------------
zzdolar ()
{
	zzzz -h dolar $1 && return

	# Faz a consulta e filtra o resultado
	$ZZWWWDUMP 'http://br.invertia.com/mercados/divisas/tiposdolar.aspx' |
		sed '
			# VocÃª acredita que essa sopa de letrinhas funciona?
			# Pois Ã©, eu tambÃ©m nÃ£o... Mas funciona :)

			s/^ *//
			/Data:/,/Turismo/!d
			/percent/d
			s/  */ /g
			s/.*Data: \(.*\)/\1 compra   venda   hora/
			s|^[1-9]/|0&|
			s@^\([0-9][0-9]\)/\([0-9]/\)@\1/0\2@
			s/^D.lar //
			s/- Corretora//
			s/ SP//g
			s/ [-+]\{0,1\}[0-9.,]\{1,\}  *%$//
			s/al /& /
			s/lo /&   /
			s/mo /&	/
			s/ \([0-9]\) / \1.000 /
			s/\.[0-9]\>/&0/g
			s/\.[0-9][0-9]\>/&0/g
			/^[^0-9]/s/[0-9] /&  /g
			/Var\.%/d
			s/Turismo../Turismo     /' |
		sed '/^Compra/d'
}


# ----------------------------------------------------------------------------
# http://br.invertia.com
# Busca a cotaÃ§Ã£o de vÃ¡rias moedas (mais de 100!) em relaÃ§Ã£o ao dÃ³lar.
# Com a opÃ§Ã£o -t, mostra TODAS as moedas, sem ela, apenas as principais.
# Ã possÃ­vel passar vÃ¡rias palavras de pesquisa para filtrar o resultado.
# Obs.: Hora GMT, DÃ³lares por unidade monetÃ¡ria para o Euro e a Libra.
# Uso: zzmoeda [-t] [pesquisa]
# Ex.: zzmoeda
#      zzmoeda -t
#      zzmoeda euro libra
#      zzmoeda -t peso
# ----------------------------------------------------------------------------
zzmoeda ()
{
	zzzz -h moeda $1 && return

	local extra dados formato linha
	local url='http://br.invertia.com/mercados/divisas'
	local padrao='.'

	# Devemos mostrar todas as moedas?
	if [ "$1" = '-t' ]
	then
		extra='divisasregion.aspx?idtel=TODAS'
		shift
	fi
	
	# Prepara o filtro para pesquisar todas as palavras informadas (OU)
	[ "$1" ] && padrao=$(echo $* | sed 's/ /\\|/g')

	# Faz a consulta e filtra o resultado
	dados=$(
		$ZZWWWDUMP "$url/$extra" |
		sed '
			# Limpeza
			/IFRAME:/d
			s/\[.*]//
			s/^  *//
			/[0-9][0-9]$/!d
			
			# Apaga variaÃ§Ã£o (deixa apenas variaÃ§Ã£o-%)
			s/\(.*\) -\{0,1\}[0-9][0-9]*,[0-9]\{4\}/\1/
			
			# Adiciona '-' nas colunas vazias de compra
			/[0-9][,.][0-9]\{4\}.*[0-9][,.][0-9]\{4\}/!s/[0-9][0-9]*[,.][0-9]\{4\}/-  &/

			# Tira espaÃ§o da sigla do Peso Mexicano (MXP 24H)
			s/ \([24][48]H\) /-\1 /

			# Separa os campos por @, do fim ao inÃ­cio da linha
			s/  */ /g
			s/\(.*\) /\1@/
			s/\(.*\) /\1@/
			s/\(.*\) /\1@/
			s/\(.*\) /\1@/
			s/\(.*\) /\1@/
			
			# Manda o nome da moeda lÃ¡ pro final da linha
			# No inÃ­cio desalinha, o printf %s conta UTF errado
			s/\([^@]*\)@\(.*\)/\2@\1/
			
			# EspaÃ§os viram _ para nÃ£o atrapalharem
			y/ /_/' |
		tr @ \\t |
		grep -i "$padrao"
	)
	
	# Pescamos algo?
	[ "$dados" ] || return
	
	# Sim! EntÃ£o formate uma tabela bonitinha com o resultado
	formato='%-7s %12s %12s %6s %11s  %s'

	printf "$formato\n" Sigla Compra Venda Var.% Hora Moeda
	
	echo "$dados" |
		while read linha
		do
			printf "$formato\n" $linha | tr _ ' '
		done
}


# DESATIVADA: Agora os sites usam AJAX :(
# # ----------------------------------------------------------------------------
# # http://www.itautrade.com.br e http://www.bovespa.com.br
# # Busca a cotaÃ§Ã£o de uma aÃ§Ã£o na Bovespa.
# # Obs.: As cotaÃ§Ãµes tÃªm delay de 15 min em relaÃ§Ã£o ao preÃ§o atual no pregÃ£o
# #       Com a opÃ§Ã£o -i, Ã© mostrado o Ã­ndice bovespa
# # Autor: Denis Dias de Lima <denis (a) concatenum com>
# # Uso: zzbovespa [-i] cÃ³digo-da-aÃ§Ã£o
# # Ex.: zzbovespa petr4
# #      zzbovespa -i
# #      zzbovespa
# # ----------------------------------------------------------------------------
# zzbovespa ()
# {
# 	zzzz -h bovespa $1 && return
# 
# 	local url='http://www.bovespa.com.br/'
# 
# 	[ "$1" ] || {
# 		$ZZWWWDUMP "$url/Indices/CarteiraP.asp?Indice=Ibovespa" |
# 			sed '/^ *CÃ³d/,/^$/!d'
# 		return
# 	}
# 	[ "$1" = "-i" ] && {
# 		$ZZWWWHTML "$url/Home/HomeNoticias.asp" |
# 			sed -n '
# 				/Ibovespa -->/,/IBrX/ {
# 					//d
# 					s/<[^>]*>//g
# 					s/[[:space:]]*//g
# 					s/^&.*\;//
# 					/^$/d
# 					p
# 				}' |
# 			sed '
# 				/^Pon/ {
# 					N
# 					s/^/		   /
# 					s/\n/   /
# 					b
# 				}
# 
# 				/^IBO/ N
# 				N
# 				s/\n/  /g
# 				/^<.-- /d
# 
# 				:a
# 				s/^\([^0-9]\{1,10\}\)\([0-9][0-9]*\)/\1 \2/
# 				ta'
# 		return
# 	}
# 	url='http://www.itautrade.com.br/itautradenet/Finder/Finder.aspx?Papel='
# 	$ZZWWWDUMP "$url$1" |
# 		sed '
# 			/AÃ§Ã£o/,/Oferta/!d
# 			/FracionÃ¡rio/,/Oferta/!d
# 			//d
# 			/\.gif/d
# 			s/^ *//
# 			/Milhares/q'
# }


# ----------------------------------------------------------------------------
# http://www.wikipedia.org
# Procura na WikipÃ©dia, a enciclopÃ©dia livre.
# Obs.: Se nenhum idioma for especificado, Ã© utilizado o portuguÃªs.
#
# Idiomas: de (alemÃ£o)    eo (esperanto)  es (espanhol)  fr (francÃªs)
#          it (italiano)  ja (japonÃªs)    la (latin)     pt (portuguÃªs)
#
# Uso: zzwikipedia [-idioma] palavra(s)
# Ex.: zzwikipedia sed
#      zzwikipedia Linus Torvalds
#      zzwikipedia -pt Linus Torvalds
# ----------------------------------------------------------------------------
zzwikipedia ()
{
	zzzz -h wikipedia $1 && return

	local url
	local idioma='pt'

	# Se o idioma foi informado, guarda-o, retirando o hÃ­fen
	if [ "${1#-}" != "$1" ]
	then
		idioma="${1#-}"
		shift
	fi
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso wikipedia; return; }

	# Faz a consulta e filtra o resultado, paginando
	url="http://$idioma.wikipedia.org/wiki/"
	$ZZWWWDUMP "$url$(echo $* | sed 's/  */_/g')" |
		sed '
			# Limpeza do conteÃºdo
			/^Views$/,$ d
			/^Vistas$/,$ d
			/^   #Wikipedia (/d
			/^From Wikipedia,/d
			/^Origem: WikipÃ©dia,/d
			/^   Jump to: /d
			/^   Ir para: /d
			/^   This article does not cite any references/d
			/^   Please help improve this article/d
			/^   Wikipedia does not have an article with this exact name./q
			s/^\[edit\] //
			s/^\[editar\] //
			 
			# Guarda URL da pÃ¡gina e mostra no final, apÃ³s Categorias
			/^   Obtido em "/ { H; d; }
			/^   Retrieved from "/ { H; d; }
			/^   Categor[a-z]*: /G' |
		cat -s
}


# DESATIVADA: Consultar 2003 Ã© inÃºtil e os anos atuais Ã© travado com CAPTCHA
# # ----------------------------------------------------------------------------
# # http://www.receita.fazenda.gov.br
# # Consulta os lotes de restituiÃ§Ã£o do imposto de renda.
# # Obs.: Funciona para os anos de 2001, 2002 e 2003.
# # Uso: zzirpf ano nÃºmero-cpf
# # Ex.: zzirpf 2003 123.456.789-69
# # ----------------------------------------------------------------------------
# zzirpf ()
# {
# 	zzzz -h irpf $1 && return
# 	
# 	local url='http://www.receita.fazenda.gov.br/Scripts/srf/irpf'
# 	local ano=$1
# 	local z=${ano#200}
# 
# 	# VerificaÃ§Ã£o dos parÃ¢metros
# 	[ "$2" ] || { zztool uso irpf; return; }
# 	
# 	[ "$z" != 1 -a "$z" != 2 -a "$z" != 3 ] && {
# 		echo "Ano invÃ¡lido '$ano'. Deve ser 2001, 2002 ou 2003."
# 		return
# 	}
# 	$ZZWWWDUMP "$url/$ano/irpf$ano.dll?VerificaDeclaracao&CPF=$2" |
# 		sed '1,8d; s/^ */  /; /^  \[BUTTON\]/,$d'
# }


# DESATIVADA: Agora o site dos Correios usa AJAX :(
# # ----------------------------------------------------------------------------
# # http://www.correios.com.br/servicos/cep
# # Busca o CEP de qualquer rua de qualquer cidade do paÃ­s ou vice-versa.
# # Uso: zzcep estado cidade rua
# # Ex.: zzcep PR curitiba rio gran
# #      zzcep RJ 'Rio de Janeiro' Vinte de
# # ----------------------------------------------------------------------------
# zzcep ()
# {
# 	zzzz -h cep $1 && return
# 
# 	local r c
# 	local url='http://www.correios.com.br/servicos/cep'
# 	local e="$1"
# 
# 	# VerificaÃ§Ã£o dos parÃ¢metros
# 	[ "$3" ] || { zztool uso cep; return; }
# 
# 	c=$(echo "$2"| sed "$ZZSEDURL")
# 	shift
# 	shift
# 	r=$(echo "$*"| sed "$ZZSEDURL")
# 	echo "UF=$e&Localidade=$c&Tipo=&Logradouro=$r" |
# 		$ZZWWWPOST "$url" |
# 		sed -n '
# 			/^ *UF:/,/^$/ {
# 				/PÃ¡gina Anter/d
# 				s/.*Ã³xima PÃ¡g.*/...CONTINUA/
# 				p
# 			}'
# }


# DESATIVADA: Agora a consulta Ã© travada com CAPTCHA
# # ----------------------------------------------------------------------------
# # http://www.pr.gov.br/detran
# # Consulta dÃ©bitos do veÃ­culo, como licenciamento, IPVA e multas (detran-PR)
# # Uso: zzdetranpr nÃºmero-renavam
# # Ex.: zzdetranpr 123456789
# # ----------------------------------------------------------------------------
# zzdetranpr ()
# {
# 	zzzz -h detranpr $1 && return
# 
# 	local url='http://celepar7.pr.gov.br/detran_novo/consultas/veiculos/deb_novo.asp'
# 
# 	# VerificaÃ§Ã£o dos parÃ¢metros
# 	[ "$1" ] || { zztool uso detranpr; return; }
# 
# 	# Faz a consulta e filtra o resultado (usando magia negra)
# 	$ZZWWWDUMP "$url?ren=$1" |
# 		sed 's/^  *//' |
# 		sed '
# 			# Remove linhas em branco
# 			/^$/ d
# 
# 			# Transforma barra horizontal em linha em branco
# 			s/___*//
# 
# 			# Apaga a lixarada
# 			1,/^Data: / d
# 			/^Informa..es do Ve.culo/ d
# 			/^Discrimina..o dos D.bitos/ d
# 			/\[BUTTON\]/,$ d
# 			/^Discrimina..o das Multas/,/^Resumo das Multas/ d
# 
# 			# Quebra a linha para dados da segunda coluna da tabela
# 			s/Renavam:/@&/
# 			s/Ano de Fab/@&/
# 			s/Combust.vel:/@&/
# 			s/Cor:/@&/
# 			' |
# 		tr @ '\n'
# }


# ----------------------------------------------------------------------------
# http://www.detran.sp.gov.br
# Consulta dÃ©bitos do veÃ­culo, como licenciamento, IPVA e multas (Detran-SP).
# Autor: Elton SimÃµes Baptista <elton (a) inso com br>
# Uso: zzdetransp nÃºmero-renavam
# Ex.: zzdetransp 123456789
# ----------------------------------------------------------------------------
zzdetransp ()
{
	zzzz -h detransp $1 && return

	local url='http://www1.ssp.sp.gov.br/multas/detran/resultMultas.asp'

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso detransp; return; }
	
	# Faz a consulta e filtra o resultado
	echo "renavam=$1&submit=Pesquisar" |
		$ZZWWWPOST "$url" |
		sed '
			1d
			s/^  *//
			/^\[/d
			/^Esta pesquisa tem /, $ d'
}


# ----------------------------------------------------------------------------
# http://www1.caixa.gov.br/loterias
# Consulta os resultados da quina, megasena, duplasena, lotomania e lotofÃ¡cil.
# Obs.: Se nenhum argumento for passado, todas as loterias sÃ£o mostradas.
# Uso: zzloteria [quina | megasena | duplasena | lotomania | lotofacil]
# Ex.: zzloteria
#      zzloteria quina megasena
# ----------------------------------------------------------------------------
zzloteria ()
{
	zzzz -h loteria $1 && return

	local dump numero_concurso data resultado acumulado tipo
	local url='http://www1.caixa.gov.br/loterias/loterias'
	local tipos='quina megasena duplasena lotomania lotofacil'
	
	# O padrÃ£o Ã© mostrar todos os tipos, mas o usuÃ¡rio pode informar alguns
	[ "$1" ] && tipos=$*

	# Para cada tipo de loteria...
	for tipo in $tipos
	do
		zztool eco $tipo:

		# HÃ¡ vÃ¡rias pegadinhas neste cÃ³digo. Alguns detalhes:
		# - A variÃ¡vel $dump Ã© um cache local do resultado
		# - Ã usado ZZWWWDUMP+filtros (e nÃ£o ZZWWWHTML) para forÃ§ar a saÃ­da em UTF-8
		# - O resultado Ã© deixado como uma Ãºnica longa linha
		# - O resultado sÃ£o vÃ¡rios campos separados por pipe |
		# - Cada tipo de loteria traz os dados em posiÃ§Ãµes (e formatos) diferentes :/
		
		dump=$($ZZWWWDUMP "$url/$tipo/${tipo}_pesquisa.asp" |
			tr -d \\n |
			sed 's/  */ /g ; s/^ //') 
		
		# O nÃºmero do concurso Ã© sempre o primeiro campo
		numero_concurso=$(echo "$dump" | cut -d '|' -f 1)

		case "$tipo" in
			lotomania)
				# O resultado vem separado em campos distintos. Exemplo:
				# |01|04|06|12|21|25|27|36|42|44|50|51|53|59|68|69|74|78|87|91|91|
				
				data=$(     echo "$dump" | cut -d '|' -f 42)
				acumulado=$(echo "$dump" | cut -d '|' -f 69,70)
				resultado=$(echo "$dump" | cut -d '|' -f 7-26 |
			 		sed 's/|/@/10 ; s/|/ - /g' |
					tr @ '\n'
				)
			;;
			lotofacil)
				# O resultado vem separado em campos distintos. Exemplo:
				# |01|04|07|08|09|10|12|14|15|16|21|22|23|24|25|
				
				data=$(     echo "$dump" | cut -d '|' -f 35)
				acumulado=$(echo "$dump" | cut -d '|' -f 54,55)
				resultado=$(echo "$dump" | cut -d '|' -f 4-18 |
					sed 's/|/@/10 ; s/|/@/5 ; s/|/ - /g' |
					tr @ '\n'
				)
			;;
			megasena)
				# O resultado vem separado por asteriscos. Exemplo:
				# | * 16 * 58 * 43 * 37 * 52 * 59 |
				
				data=$(     echo "$dump" | cut -d '|' -f 12)
				acumulado=$(echo "$dump" | cut -d '|' -f 22,23)
				resultado=$(echo "$dump" | cut -d '|' -f 21 |
					tr '*' '-'  |
					tr '|' '\n' |
					sed 's/^ - //'
				)
			;;
			duplasena)
				# O resultado vem separado por asteriscos, tendo dois grupos
				# numÃ©ricos: o primeiro e segundo resultado. Exemplo:
				# | * 05 * 07 * 09 * 21 * 38 * 40 | * 05 * 17 * 20 * 22 * 31 * 45 |

				data=$(     echo "$dump" | cut -d '|' -f 18)
				acumulado=$(echo "$dump" | cut -d '|' -f 23,24)
				resultado=$(echo "$dump" | cut -d '|' -f 4,5 |
					tr '*' '-'  |
					tr '|' '\n' |
					sed 's/^ - //'
				)
			;;
			quina)
				# O resultado vem duplicado em um Ãºnico campo, sendo a segunda
				# parte o resultado ordenado numericamente. Exemplo:
				# | * 69 * 42 * 13 * 56 * 07 * 07 * 13 * 42 * 56 * 69 |
				
				data=$(     echo "$dump" | cut -d '|' -f 17)
				acumulado=$(echo "$dump" | cut -d '|' -f 18,19)
				resultado=$(echo "$dump" | cut -d '|' -f 15 |
					sed 's/\* /|/6' |
					tr '*' '-'  |
					tr '|' '\n' |
					sed 's/^ - // ; 1d'
				)
			;;
		esac
		
		# Mostra o resultado na tela (caso encontrado algo)
		if [ "$resultado" ]
		then
			echo "$resultado" | sed 's/^/   /'
			echo "   Concurso $numero_concurso ($data)"
			[ "$acumulado" ] && echo "   Acumulado em R$ $acumulado" | sed 's/|/ para /'
			echo
		fi
	done
}



# ----------------------------------------------------------------------------
# #### P R O G R A M A S                                         (Internet)
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# http://freshmeat.net
# Procura por programas na base do site Freshmeat.
# Uso: zzfreshmeat programa
# Ex.: zzfreshmeat tetris
# ----------------------------------------------------------------------------
zzfreshmeat ()
{
	zzzz -h freshmeat $1 && return
	
	local url='http://freshmeat.net/search/'
	local padrao=$1
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso freshmeat; return; }
	
	# Faz a consulta e filtra o resultado
	$ZZWWWLIST "$url?q=$padrao" |
		sed -n 's@.*\(http.*freshmeat.net/projects/.*\)/@\1@p'
}


# ----------------------------------------------------------------------------
# http://rpmfind.net/linux
# Procura por pacotes RPM em vÃ¡rias distribuiÃ§Ãµes de Linux.
# Obs.: A arquitetura padrÃ£o de procura Ã© a i386.
# Uso: zzrpmfind pacote [distro] [arquitetura]
# Ex.: zzrpmfind sed
#      zzrpmfind lilo mandr i586
# ----------------------------------------------------------------------------
zzrpmfind ()
{
	zzzz -h rpmfind $1 && return

	local url='http://rpmfind.net/linux/rpm2html/search.php'
	local pacote=$1
	local distro=$2
	local arquitetura=${3:-i386}
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso rpmfind; return; }
	
	# Faz a consulta e filtra o resultado
	zztool eco 'ftp://rpmfind.net/linux/'
	$ZZWWWLIST "$url?query=$pacote&submit=Search+...&system=$distro&arch=$arquitetura" |
		sed -n '/ftp:\/\/rpmfind/ s@^[^A-Z]*/linux/@  @p' |
		sort
}



# ----------------------------------------------------------------------------
# #### D I V E R S O S                                           (Internet)
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# http://www.iana.org/cctld/cctld-whois.htm
# Busca a descriÃ§Ã£o de um cÃ³digo de paÃ­s da internet (.br, .ca etc).
# Uso: zzdominiopais [.]cÃ³digo|texto
# Ex.: zzdominiopais .br
#      zzdominiopais br
#      zzdominiopais republic
# ----------------------------------------------------------------------------
zzdominiopais ()
{
	zzzz -h dominiopais $1 && return

	local url='http://www.iana.org/root-whois/index.html'
	local cache="$ZZTMP.dominiopais"
	local cache_sistema='/usr/share/zoneinfo/iso3166.tab'
	local padrao=$1

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dominiopais; return; }
	
	# Se o padrÃ£o inicia com ponto, retira-o e casa somente cÃ³digos
	if [ "${padrao#.}" != "$padrao" ]
	then
		padrao="^${padrao#.}"
	fi

	# Primeiro tenta encontrar no cache do sistema
	if test -f "$cache_sistema"
	then
		# O formato padrÃ£o de saÃ­da Ã© BR - Brazil
		grep -i "$padrao" $cache_sistema |
			tr -s '\t ' ' ' |
			sed '/^#/d ; / - /!s/ / - /'
		return
	fi

	# Ops, nÃ£o hÃ¡ cache do sistema, entÃ£o tentamos o cache da Internet

	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWDUMP "$url" |
			sed -n 's/^  *\.// ; s/country-code/-/p' > "$cache"
	fi

	# Pesquisa no cache
	grep -i "$padrao" "$cache"
}


# ----------------------------------------------------------------------------
# http://funcoeszz.net/locales.txt
# Busca o cÃ³digo do idioma (locale). Por exemplo, portuguÃªs Ã© pt_BR.
# Com a opÃ§Ã£o -c, pesquisa somente nos cÃ³digos e nÃ£o em sua descriÃ§Ã£o.
# Uso: zzlocale [-c] cÃ³digo|texto
# Ex.: zzlocale chinese
#      zzlocale -c pt
# ----------------------------------------------------------------------------
zzlocale ()
{
	zzzz -h locale $1 && return
	
	local url='http://funcoeszz.net/locales.txt'
	local cache="$ZZTMP.locale"
	local padrao="$1"

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-c' ]
	then
		# PadrÃ£o de pesquisa vÃ¡lido para Ãºltima palavra da linha (cÃ³digo)
		padrao="$2[^ ]*$"
		shift
	fi

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso locale; return; }
	
	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWDUMP "$url" > "$cache"
	fi
		
	# Faz a consulta
	grep -i -- "$padrao" "$cache"
}


# ----------------------------------------------------------------------------
# http://pgp.mit.edu
# Busca a identificaÃ§Ã£o da chave PGP, fornecido o nome ou e-mail da pessoa.
# Uso: zzchavepgp nome|e-mail
# Ex.: zzchavepgp Carlos Oliveira da Silva
#      zzchavepgp carlos@dominio.com.br
# ----------------------------------------------------------------------------
zzchavepgp ()
{
	zzzz -h chavepgp $1 && return

	local url='http://pgp.mit.edu:11371'
	local padrao=$(echo $*| sed "$ZZSEDURL")

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso chavepgp; return; }

	$ZZWWWDUMP "http://pgp.mit.edu:11371/pks/lookup?search=$padrao&op=index" |
		sed 1,2d
}


# ----------------------------------------------------------------------------
# http://www.dicas-l.unicamp.br
# Procura por dicas sobre determinado assunto na lista Dicas-L.
# Obs.: As opÃ§Ãµes do grep podem ser usadas (-i jÃ¡ Ã© padrÃ£o).
# Uso: zzdicasl [opÃ§Ã£o-grep] palavra(s)
# Ex.: zzdicasl ssh
#      zzdicasl -w vi
#      zzdicasl -vEw 'windows|unix|emacs'
# ----------------------------------------------------------------------------
zzdicasl ()
{
	zzzz -h dicasl $1 && return

	local opcao_grep
	local url='http://www.dicas-l.com.br/dicas-l/'

	# Guarda as opÃ§Ãµes para o grep (caso informadas)
	[ "${1##-*}" ] || {
		opcao_grep=$1
		shift
	}

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dicasl; return; }

	# Faz a consulta e filtra o resultado
	zztool eco "$url"
	$ZZWWWHTML "$url" |
		grep -i $opcao_grep "$*" |
		sed -n 's@^<LI><A HREF=\([^>]*\)> *\([^ ].*\)</A>@\1: \2@p'
}


# ----------------------------------------------------------------------------
# http://registro.br
# Mostra informaÃ§Ãµes sobre domÃ­nios brasileiros (.com.br, .org.br, etc).
# Uso: zzwhoisbr domÃ­nio
# Ex.: zzwhoisbr abc.com.br
#      zzwhoisbr www.abc.com.br
# ----------------------------------------------------------------------------
zzwhoisbr ()
{
	zzzz -h whoisbr $1 && return

	local url='http://registro.br/cgi-bin/whois/'
	local dominio="${1#www.}" # tira www do inÃ­cio

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso whoisbr; return; }

	# Faz a consulta e filtra o resultado
	$ZZWWWDUMP "$url?qr=$dominio" | 
		sed '
			s/^  *//
			1,/^%/d
			/^remarks/,$d
			/^%/d
			/^alterado/d
			/atualizado /d'
}


# ----------------------------------------------------------------------------
# http://www.whatismyip.com
# Mostra o seu nÃºmero IP (externo) na Internet.
# Uso: zzipinternet
# Ex.: zzipinternet
# ----------------------------------------------------------------------------
zzipinternet ()
{
	zzzz -h ipinternet $1 && return

	local url='http://whatismyip.com/automation/n09230945.asp'

	# O resultado jÃ¡ vem pronto!
	$ZZWWWHTML "$url"
	echo
}


# ----------------------------------------------------------------------------
# http://www.ibiblio.org
# Procura documentos do tipo HOWTO.
# Uso: zzhowto [--atualiza] palavra
# Ex.: zzhowto apache
#      zzhowto --atualiza
# ----------------------------------------------------------------------------
zzhowto ()
{
	zzzz -h howto $1 && return

	local padrao
	local cache="$ZZTMP.howto"
	local url='http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/'

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso howto; return; }

	# ForÃ§a atualizaÃ§Ã£o da listagem apagando o cache
	if [ "$1" = '--atualiza' ]
	then
		rm -f "$cache"
		shift
	fi

	padrao=$1
	
	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWHTML "$url" |
			sed -n '/alt="\[TXT\]"/ {
				s/^.*href="\([^"]*\).*/\1/
				p
			}' > "$cache"
	fi
	
	# Pesquisa o termo (se especificado)
	if [ "$padrao" ]
	then
		zztool eco "$url"
		grep -i "$padrao" "$cache"
	fi
}


# ----------------------------------------------------------------------------
# http://... - vÃ¡rios
# Busca as Ãºltimas notÃ­cias sobre Linux em sites nacionais.
# Obs.: Cada site tem uma letra identificadora que pode ser passada como
#       parÃ¢metro, para informar quais sites vocÃª quer pesquisar:
#
#         Y)ahoo Linux         B)r Linux
#         C)ipsga              N)otÃ­cias linux
#         V)iva o Linux        U)nder linux
#
# Uso: zznoticiaslinux [sites]
# Ex.: zznoticiaslinux
#      zznoticiaslinux yn
# ----------------------------------------------------------------------------
zznoticiaslinux ()
{
	zzzz -h noticiaslinux $1 && return

	local url limite
	local n=5
	local sites='byvucin'

	limite="sed ${n}q"
	
	[ "$1" ] && sites="$1"
	
	# Yahoo
	if zztool grep_var y $sites
	then
		url='http://br.news.yahoo.com/tecnologia/linux'
		echo
		zztool eco "* Yahoo Linux ($url):"
		$ZZWWWHTML "$url" |
			sed -n '
				/topheadline/ {
					n
					s,</a>.*,,
					s/<[^>]*>//gp
				}
				/clearfix/ {
			 		n
					s/<[^>]*>//gp
				}' |
			sed 's/^[[:blank:]]*//' |
			$limite
	fi
	
	# Viva o Linux
	if zztool grep_var v $sites
	then
		url='http://www.vivaolinux.com.br'
		echo
		zztool eco "* Viva o Linux ($url):"
		
		# TODO Em alguns sistemas as notÃ­cias vÃªm gzipadas, tendo que
		# abrir com gzip -d. Reportado por Rodrigo Azevedo.
		
		$ZZWWWHTML "$url/index.rdf" |
			sed -n '1,/<item>/d;s@.*<title>\(.*\)</title>@\1@p' |
			$limite
	fi
	
	# Cipsga
	if zztool grep_var c $sites
	then
		url='http://www.cipsga.org.br'
		echo
		zztool eco "* CIPSGA ($url):"
		$ZZWWWDUMP "$url" |
			cat -s |
		 	sed '1,/vantagens exclusivas/d' |
		  	sed -n '/^$/{ n; p; }' |
		 	sed '/^$/q ; s/^  *//' |
			$limite
	fi
	
	# Br Linux
	if zztool grep_var b $sites
	then
		url='http://br-linux.org/feed/'
		echo
		zztool eco "* BR Linux ($url):"
		$ZZWWWHTML "$url" |
			sed -n '1,/<item>/d ; s/.*<title>// ; s@</title>@@p' |
			$limite
	fi
	
	# UnderLinux
	if zztool grep_var u $sites
	then
		url='http://feeds.feedburner.com/underlinux'
		echo
		zztool eco "* UnderLinux ($url):"
		$ZZWWWHTML "$url" |
			sed -n '1,/<item>/d ; s/.*<title>// ; s@</title>@@p' |
			$limite
	fi
	
	# NotÃ­cias Linux
	if zztool grep_var n $sites
	then
		url='http://www.noticiaslinux.com.br'
		echo
		zztool eco "* NotÃ­cias Linux ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/<[hH]3>/{s/<[^>]*>//g;s/^[[:blank:]]*//g;p;}' |
			$limite
	fi
}


# ----------------------------------------------------------------------------
# http://... - vÃ¡rios
# Busca as Ãºltimas notÃ­cias sobre linux em sites em inglÃªs.
# Obs.: Cada site tem uma letra identificadora que pode ser passada como
#       parÃ¢metro, para informar quais sites vocÃª quer pesquisar:
#
#          F)reshMeat         Linux T)oday
#          S)lashDot          Linux W)eekly News
#          N)ewsForge         O)S News
#
# Uso: zzlinuxnews [sites]
# Ex.: zzlinuxnews
#      zzlinuxnews fsn
# ----------------------------------------------------------------------------
zzlinuxnews ()
{
	zzzz -h linuxnews $1 && return

	local url limite
	local n=5
	local sites='fsntwo'

	limite="sed ${n}q"
	
	[ "$1" ] && sites="$1"

	# Freshmeat
	if zztool grep_var f $sites
	then
		url='http://freshmeat.net'
		echo
		zztool eco "* FreshMeat ($url):"
		$ZZWWWHTML "$url" |
			sed '/href="\/releases/!d;s/<[^>]*>//g;s/&nbsp;//g;s/^ *- //' |
			$limite
	fi

	# Slashdot
	if zztool grep_var s $sites
	then
		url='http://slashdot.org'
		echo
		zztool eco "* SlashDot ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/<div class="title">/,/<\/div>/{/slashdot/{
		  s/<[^>]*>//g;s/^[[:blank:]]*//;p;};}' |
			$limite
	fi

	# Newsforge
	if zztool grep_var n $sites
	then
		url='http://www.newsforge.com'
		echo
		zztool eco "* NewsForge - ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/<h3>/{ n; s/<[^>]*>//gp; }' |
			sed 's/^  *//' |
			$limite
	fi

	# Linux Today
	if zztool grep_var t $sites
	then
		url='http://linuxtoday.com/backend/biglt.rss'
		echo
		zztool eco "* Linux Today ($url):"
		$ZZWWWHTML "$url" |
			sed -n '1,/<item>/d;s@.*<title>\(.*\)</title>@\1@p' |
			$limite
	fi

	# LWN
	if zztool grep_var w $sites
	then
		url='http://lwn.net/Articles'
		echo
		zztool eco "* Linux Weekly News - ($url):"
		$ZZWWWHTML "$url" |
			sed '/class="Headline"/!d;s/^ *//;s/<[^>]*>//g' |
			$limite
	fi

	# OS News
	if zztool grep_var o $sites
	then
		url='http://osnews.com'
		echo
		zztool eco "* OS News - ($url):"
		$ZZWWWDUMP "$url" |
			sed -n '/^ *By /{g;s/^ *//;p;};h' |
			$limite
	fi
}


# ----------------------------------------------------------------------------
# http://... - vÃ¡rios
# Busca as Ãºltimas notÃ­cias em sites especializados em seguranÃ§a.
# Obs.: Cada site tem uma letra identificadora que pode ser passada como
#       parÃ¢metro, para informar quais sites vocÃª quer pesquisar:
#
#       Linux Security B)rasil    Linux T)oday - Security
#       Linux S)ecurity           Security F)ocus
#       C)ERT/CC
#
# Uso: zznoticiassec [sites]
# Ex.: zznoticiassec
#      zznoticiassec bcf
# ----------------------------------------------------------------------------
zznoticiassec ()
{
	zzzz -h noticiassec $1 && return

	local url limite
	local n=5
	local sites='bsctf'

	limite="sed ${n}q"

	[ "$1" ] && sites="$1"

	# LinuxSecurity Brasil
	if zztool grep_var b $sites
	then
		url='http://www.linuxsecurity.com.br/share.php'
		echo
		zztool eco "* LinuxSecurity Brasil ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/item/,$ s@.*<title>\(.*\)</title>@\1@p' |
			$limite
	fi

	# Linux Security
	if zztool grep_var s $sites
	then
		url='http://www.linuxsecurity.com/linuxsecurity_advisories.rdf'
		echo
		zztool eco "* Linux Security ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/item/,$ s@.*<title>\(.*\)</title>@\1@p' |
			$limite
	fi

	# CERT/CC
	if zztool grep_var c $sites
	then
		url='http://www.us-cert.gov/channels/techalerts.rdf'
		echo
		zztool eco "* CERT/CC ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/item/,$ s@.*<title>\(.*\)</title>@\1@p' |
			$limite
	fi

	# Linux Today - Security
	if zztool grep_var t $sites
	then
		url='http://linuxtoday.com/security/index.html'
		echo
		zztool eco "* Linux Today - Security ($url):"
		$ZZWWWHTML "$url" |
			sed -n '/class="nav"><B>/s/<[^>]*>//gp' |
			$limite
	fi

	# Security Focus
	if zztool grep_var f $sites
	then
		url='http://www.securityfocus.com/bid'
		echo
		zztool eco "* SecurityFocus Vulns Archive ($url):"
		$ZZWWWDUMP "$url" |
			sed -n '
				/^ *\([0-9]\{4\}-[0-9][0-9]-[0-9][0-9]\)/ {
					G
					s/^ *//
					s/\n//p
				}
				h' |
			$limite
	fi
}


# ----------------------------------------------------------------------------
# http://... - vÃ¡rios
# Mostra os Ãºltimos 5 avisos de seguranÃ§a de sistemas de Linux/UNIX.
# Suportados: Debian Fedora FreeBSD Gentoo Mandriva Slackware Suse Ubuntu.
# Uso: zzsecurity [distros]
# Ex.: zzsecutiry
#      zzsecurity fedora
#      zzsecurity debian gentoo
# ----------------------------------------------------------------------------
zzsecurity ()
{
	zzzz -h security $1 && return

	local url limite distros
	local n=5
	local distros='debian fedora freebsd gentoo mandriva slackware suse ubuntu'
	
	limite="sed ${n}q"

	[ "$1" ] && distros="$(echo $* | zzminusculas)"
	
	# Debian
	if zztool grep_var debian $distros
	then
		url='http://www.debian.org'
		echo
		zztool eco '** AtualizaÃ§Ãµes Debian woody'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed -n '
				/Security Advisories/,/_______/ {
					/\[[0-9]/ s/^ *//p
				}' |
			$limite
	fi

	# Slackware
	if zztool grep_var slackware $distros
	then
		echo
		zztool eco '** AtualizaÃ§Ãµes Slackware'
		url='http://www.slackware.com/security/list.php?l=slackware-security&y=2005'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed '
				/[0-9]\{4\}-[0-9][0-9]/!d
				s/\[sla.*ty\]//
				s/^  *//' |
			$limite
	fi

	# Gentoo
	if zztool grep_var gentoo $distros
	then
		echo
		zztool eco '** AtualizaÃ§Ãµes Gentoo'
		url='http://www.gentoo.org/security/en/index.xml'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed -n '
				s/^  *//
				/^GLSA/, /^$/ !d
				/[0-9]\{4\}/ {
					s/\([-0-9]* \) *[a-zA-Z]* *\(.*[^ ]\)  *[0-9][0-9]* *$/\1\2/
					p
				}' |
			$limite
	fi

	# Mandriva
	if zztool grep_var mandriva $distros
	then
		echo
		zztool eco '** AtualizaÃ§Ãµes Mandriva'
		url='http://www.mandriva.com/en/rss/feed/security'
		echo "$url"
		$ZZWWWHTML "$url" |
			sed -n '/<title>/{
				s/<[^>]*>//g
				s/^ *//
				/^Mandriva/d
				p
			}' |
			$limite
	fi

	# Suse
	if zztool grep_var suse $distros
	then
		echo
		zztool eco '** AtualizaÃ§Ãµes Suse'
		url='http://www.novell.com/linux/security/advisories.html'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed -n 's/^.* \([0-9][0-9] *... *[0-9][0-9][0-9][0-9]\)/\1/p' |
			$limite
	fi

	# Fedora
	if zztool grep_var fedora $distros
	then
		echo
		zztool eco '** AtualizaÃ§Ãµes Fedora'
		url='http://www.linuxsecurity.com/content/blogcategory/89/102/'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed -n 's/^ *\([Ff]edora *[0-9]\{1,\} *[Uu]pdate.*:.*\) *$/\1/p' |
			$limite
	fi

	# FreeBSD
	if zztool grep_var freebsd $distros
	then
		echo
		zztool eco '** AtualizaÃ§Ãµes FreeBSD'
		url='http://www.freebsd.org/security/advisories.rdf'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed -n '
				/<title>/ {
					s/<[^>]*>//g
					s/^ *//
					/BSD-SA/p
				}' |
			$limite
	fi
	
	# Ubuntu
	if zztool grep_var ubuntu $distros
	then
		url='http://www.ubuntu.com/taxonomy/term/2/0/feed'
		echo
		zztool eco '** AtualizaÃ§Ãµes Ubuntu'
		echo "$url"
		$ZZWWWDUMP "$url" |
			sed -n '/item/,$ s@.*<title>\(.*\)</title>@\1@p' |
			$limite
	fi
}


# ----------------------------------------------------------------------------
# http://google.com
# Pesquisa no Google diretamente pela linha de comando.
# Uso: zzgoogle [-n <nÃºmero>] palavra(s)
# Ex.: zzgoogle receita de bolo de abacaxi
#      zzgoogle -n 5 ramones papel higiÃªnico cachorro
# ----------------------------------------------------------------------------
# FIXME: zzgoogle rato roeu roupa rei roma [PPS], [PDF]
zzgoogle ()
{
	zzzz -h google $1 && return

	local padrao
	local limite=10
	local url='http://www.google.com.br/search'

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-n' ]
	then
		limite=$2
		shift; shift
	fi

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso google; return; }

	# Prepara o texto a ser pesquisado
	padrao=$(echo "$*" | sed "$ZZSEDURL")
	[ "$padrao" ] || return 0
	
	# Pesquisa, baixa os resultados e filtra
	#
	# O Google condensa tudo em um Ãºnica longa linha, entÃ£o primeiro Ã© preciso
	# inserir quebras de linha antes de cada resultado. Identificadas as linhas
	# corretas, o filtros limpa os lixos e formata o resultado.
	
	$ZZWWWHTML "$url?q=$padrao&num=$limite&ie=UTF-8&oe=UTF-8&hl=pt-BR" |
		sed 's/class=g/\
/g' |
		sed '
			/^><a href="\([^"]*\)" class=l>/!d
			s/^><a href="//
			s/" class=l>/ /
			s/<\/a>.*//
			
			# Remove tags HTML
			s/<[^>]*>//g
			
			# Restaura os caracteres especiais
			s/&gt;/>/g
			s/&lt;/</g
			s/&quot;/"/g
			s/&nbsp;/ /g
			
			s/\([^ ]*\) \(.*\)/\2\
  \1\
/'
}


# DESATIVADA: NÃ£o funciona. Ã preciso encontrar outro site e fazer o filtro.
# # ----------------------------------------------------------------------------
# # http://letssingit.com
# # Busca letras de mÃºsicas, procurando pelo nome da mÃºsica.
# # Obs.: Se encontrar mais de uma, mostra a lista de possibilidades.
# # Uso: zzletrademusica texto
# # Ex.: zzletrademusica punkrock
# #      zzletrademusica kkk took my baby
# # ----------------------------------------------------------------------------
# zzletrademusica ()
# {
# 	zzzz -h letrademusica $1 && return
# 	
# 	local padrao=$(echo "$*" | sed "$ZZSEDURL")
# 	local url=http://letssingit.com/cgi-exe/am.cgi
# 
# 	# VerificaÃ§Ã£o dos parÃ¢metros
# 	[ "$1" ] || { zztool uso letrademusica; return; }
# 	
# 	$ZZWWWDUMP "$url?a=search&p=1&s=$padrao&l=song" |
# 		sed -n 's/^ *//;/^artist /,/Page :/p;/^Artist *:/,${/IFRAME\|^\[params/d;p;}'
# }


# DESATIVADA: NÃ£o funciona (404).
# # ----------------------------------------------------------------------------
# # http://tudoparana.globo.com/gazetadopovo/cadernog/tv.html
# # Consulta a programaÃ§Ã£o do dia dos canais abertos da TV.
# # Pode-se passar os canais e o horÃ¡rio que se quer consultar.
# #   Identificadores: B)and, C)nt, E)ducativa, G)lobo, R)ecord, S)bt, cU)ltura
# # Uso: zztv canal [horÃ¡rio]
# # Ex.: zztv bsu 19       # band, sbt e cultura, depois das 19:00
# #      zztv . 00         # todos os canais, depois da meia-noite
# #      zztv .            # todos os canais, o dia todo
# # ----------------------------------------------------------------------------
# zztv ()
# {
# 	zzzz -h tv $1 && return
# 	
# 	local a c h
# 	local url='http://tudoparana.globo.com/gazetadopovo/cadernog'
# 
# 	# VerificaÃ§Ã£o dos parÃ¢metros
# 	[ "$1" ] || { zztool uso tv; return; }
# 
# 	h=$(echo $2 | sed 's/^\(..\).*/\1/;s/[^0-9]//g')
# 	h="($h|$((h+1))|$((h+2)))"
# 	h=$(echo $h | sed 's/24/00/;s/25/01/;s/26/02/;s/\<[0-9]\>/0&/g;s@[(|)]@\\\\&@g')
# 	c=$(
# 		echo $1 |
# 		sed '
# 			s/b/2,/;s/s/4,/;s/c/6,/;
# 			s/r/7,/;s/u/9,/;s/g/12,/;s/e/59,/
# 			s/,$//;s@,@\\\\|@g'
# 	)
# 	c=$(echo $c | sed 's/^\.$/..\\?/')
# 	a=$(
# 		$ZZWWWHTML "$url/capa.phtml" |
# 		sed -n '/ana11azul.*conteudo.phtml?id=.*[tT][vV]/{ s/.*href=\"[^\"]*\/\([^\"]*\)\".*/\1/p;}'
# 	)
# 	[ "$a" ] || {
# 		echo "ProgramaÃ§Ã£o de hoje nÃ£o disponivel"
# 		return
# 	}
# 	$ZZWWWDUMP "$url/$a" |
# 		sed -e 's/^ *//;s/[Cc][Aa][Nn][Aa][Ll]/CANAL/;/^[012C]/!d;/^C[^A]/d;/^C/i \' -e . |
# 		sed "/^CANAL \($c\) *$/,/^.$/!d;/^C/,/^$h/{/^C\|^$h/!d;};s/^\.//"
# }


# ----------------------------------------------------------------------------
# http://www.acronymfinder.com
# DicionÃ¡rio de siglas, sobre qualquer assunto (como DVD, IMHO, WYSIWYG).
# Obs.: HÃ¡ um limite diÃ¡rio de consultas por IP, pode parar temporariamente.
# Uso: zzsigla sigla
# Ex.: zzsigla RTFM
# ----------------------------------------------------------------------------
zzsigla ()
{
	zzzz -h sigla $1 && return
	
	local url=http://www.acronymfinder.com/af-query.asp

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso sigla; return; }

	# Pesquisa, baixa os resultados e filtra
	$ZZWWWDUMP "$url?String=exact&Acronym=$1&Find=Find" |
		grep '\*\*\*\*' |
		sed '
			s/more info from.*//
			s/\[go\.gif\]//
			s/  *$//
			s/^ *\*\** *//'
}


# ----------------------------------------------------------------------------
# http://www.m-w.com
# Fala a pronÃºncia correta de uma palavra em inglÃªs.
# Uso: zzpronuncia palavra
# Ex.: zzpronuncia apple
# ----------------------------------------------------------------------------
zzpronuncia ()
{
	zzzz -h pronuncia $1 && return

	local wav_file wav_dir wav_url
	local palavra=$1
	local cache="$ZZTMP.$palavra.wav"
	local url='http://www.m-w.com/cgi-bin/dictionary'
	local url2='http://cougar.eb.com/soundc11'

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso pronuncia; return; }

	# O 'say' Ã© um comando do Mac OS X, aÃ­ nÃ£o precisa baixar nada
	if test -x /usr/bin/say
	then
		say $*
		return
	fi

	# Busca o arquivo WAV na Internet caso nÃ£o esteja no cache
	if ! test -f "$cache"
	then
		# Extrai o nome do arquivo no site do dicionÃ¡rio
		wav_file=$(
			$ZZWWWHTML "$url?va=$palavra" |
  			sed -n "/.*audio.pl?\([a-z0-9]*\.wav\)=$palavra.*/{s//\1/p;q;}")

		# Ops, nÃ£o extraiu nada
		if test -z "$wav_file"
		then
			echo "$palavra: palavra nÃ£o encontrada"
			return
		fi
		
		# O nome da pasta Ã© a primeira letra do arquivo (/a/apple001.wav)
		# Ou "number" se iniciar com um nÃºmero (/number/9while01.wav)
		wav_dir=$(echo $wav_file | cut -c1)
		echo $wav_dir | grep -qs '[0-9]' && wav_dir='number'
		
		# CompÃµe a URL do arquivo e salva-o localmente (cache)
		wav_url="$url2/$wav_dir/$wav_file"
		echo "URL: $wav_url"
		$ZZWWWHTML "$wav_url" > $cache
		echo "Gravado o arquivo '$cache'"
	fi
	
	# Fala que eu te escuto
	play $cache
}


# ----------------------------------------------------------------------------
# http://weather.noaa.gov/
# Mostra as condiÃ§Ãµes do tempo (clima) em um determinado local.
# Se nenhum parÃ¢metro for passado, sÃ£o listados os paÃ­ses disponÃ­veis.
# Se sÃ³ o paÃ­s for especificado, sÃ£o listadas as suas localidades.
# As siglas tambÃ©m podem ser usadas, por exemplo SBPA = Porto Alegre.
# Uso: zztempo <paÃ­s> <localidade>
# Ex.: zztempo 'United Kingdom' 'London City Airport'
#      zztempo brazil 'Curitiba Aeroporto'
#      zztempo brazil SBPA
# ----------------------------------------------------------------------------
zztempo ()
{
	zzzz -h tempo $1 && return

	local codigo_pais codigo_localidade localidades
	local pais="$1"
	local localidade="$2"
	local cache_paises=$ZZTMP.tempo
	local cache_localidades=$ZZTMP.tempo
	local url='http://weather.noaa.gov'

	# Se o cache de paÃ­ses estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache_paises"
	then
		$ZZWWWHTML "$url" | sed -n '
			/="country"/,/\/select/ {
				s/.*="\([a-zA-Z]*\)">\(.*\) <.*/\1 \2/p
			}' > "$cache_paises"
	fi

	# Se nenhum parÃ¢metro for passado, sÃ£o listados os paÃ­ses disponÃ­veis		
	if ! [ "$pais" ]
	then
		sed 's/^[^ ]*  *//' "$cache_paises"
		return
	fi

	# Grava o cÃ³digo deste paÃ­s (BR  Brazil -> BR)
	codigo_pais=$(grep -i "$1" "$cache_paises" | sed 's/  .*//' | sed 1q)

	# O paÃ­s existe?
	if ! [ "$codigo_pais" ]
	then
		echo "PaÃ­s \"$pais\" nÃ£o encontrado"
		return
	fi

	# Se o cache de locais estÃ¡ vazio, baixa listagem da Internet
	cache_localidades=$cache_localidades.$codigo_pais
	if ! test -s "$cache_localidades"
	then
		$ZZWWWHTML "$url/weather/${codigo_pais}_cc.html" | sed -n '
			/="cccc"/,/\/select/ {
				//d
				s/.*="\([a-zA-Z]*\)">/\1 /p
			}' > "$cache_localidades"
	fi

	# Se sÃ³ o paÃ­s for especificado, sÃ£o listadas as localidades deste paÃ­s
	if ! [ "$localidade" ]
	then
		cat "$cache_localidades"
		return
	fi

	# Pesquisa nas localidades
	localidades=$(grep -i "$localidade" "$cache_localidades")
	
	# A localidade existe?
	if ! [ "$localidades" ]
	then
		echo "Localidade \"$localidade\" nÃ£o encontrada"
		return
	fi	
	
	# Se mais de uma localidade for encontrada, mostre-as
	if test $(echo "$localidades" | sed -n '$=') != 1
	then
		echo "$localidades"
		return
	fi

	# Grava o cÃ³digo do local (SBCO  Porto Alegre -> SBCO)
	codigo_localidade=$(echo "$localidades" | sed 's/  .*//')

	# Faz a consulta e filtra o resultado
	echo
	$ZZWWWDUMP "$url/weather/current/${codigo_localidade}.html" | sed -n '
		/Current Weather/,/24 Hour/ {
			//d
			/____*/d
			p
		}'
}


# ----------------------------------------------------------------------------
# http://www.worldtimeserver.com
# Mostra a hora certa de um determinado local.
# Se nenhum parÃ¢metro for passado, sÃ£o listados as localidades disponÃ­veis.
# O parÃ¢metro pode ser tanto a sigla quando o nome da localidade.
# A opÃ§Ã£o -s realiza a busca somente na sigla.
# Uso: zzhoracerta [-s] local
# Ex.: zzhoracerta rio grande do sul
#      zzhoracerta -s br
#      zzhoracerta rio
#      zzhoracerta us-ny
# ----------------------------------------------------------------------------
zzhoracerta ()
{
	zzzz -h horacerta $1 && return

	local codigo localidade localidades
	local cache=$ZZTMP.horacerta
	local url='http://www.worldtimeserver.com'

	# OpÃ§Ãµes de linha de comando
	if [ "$1" = '-s' ]
	then
		shift
		codigo="$1"
	else
		localidade="$*"	
	fi
	
	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWHTML "$url/country.html" |
			sed -n 's/.*current_time_in_\([^.]*\)\.aspx">\([^<]*\)<.*/\1 -- \2/p' > "$cache"
	fi

	# Se nenhum parÃ¢metro for passado, sÃ£o listados os paÃ­ses disponÃ­veis		
	if ! [ "$localidade$codigo" ]
	then
		cat "$cache"
		return
	fi

	# Faz a pesquisa por codigo ou texto
	if [ "$codigo" ]
	then
		localidades=$(grep -i "^[^ ]*$codigo" "$cache")
	else
		localidades=$(grep -i "$localidade" "$cache")		
	fi

	# Se mais de uma localidade for encontrada, mostre-as
	if test $(echo "$localidades" | sed -n '$=') != 1
	then
		echo "$localidades"
		return
	fi

	# A localidade existe?
	if ! [ "$localidades" ]
	then
		echo "Localidade \"$localidade$codigo\" nÃ£o encontrada"
		return
	fi	
	
	# Grava o cÃ³digo da localidade (BR-RS -- Rio Grande do Sul -> BR-RS)
	localidade=$(echo "$localidades" | sed 's/ .*//')
	
	# Faz a consulta e filtra o resultado
	$ZZWWWDUMP "$url/current_time_in_$localidade.aspx" |
		sed -n '/The current time/,/UTC/p'
}


# DESATIVADA: Agora a consulta Ã© travada com CAPTCHA
# # ----------------------------------------------------------------------------
# # http://www.nextel.com.br
# # Envia uma mensagem para um telefone NEXTEL (via rÃ¡dio).
# # Obs.: O nÃºmero especificado Ã© o nÃºmero prÃ³prio do telefone (nÃ£o o ID!).
# # Uso: zznextel de para mensagem
# # Ex.: zznextel aurÃ©lio 554178787878 minha mensagem mala
# # ----------------------------------------------------------------------------
# zznextel ()
# {
# 	zzzz -h nextel $1 && return
# 	
# 	local msg
# 	local url=http://page.nextel.com.br/cgi-bin/sendPage_v3.cgi
# 	local subj=zznextel
# 	local from="$1"
# 	local to="$2"
# 
# 	# VerificaÃ§Ã£o dos parÃ¢metros
# 	[ "$3" ] || { zztool uso nextel; return; }
# 
# 	shift; shift
# 	msg=$(echo "$*" | sed "$ZZSEDURL")
# 
# 	echo "to=$to&from=$from&subject=$subj&message=$msg&count=0&Enviar=Enviar" |
# 		$ZZWWWPOST "$url" |
# 		sed '1,/^ *CENTRAL/d ; s/.*Individual/ / ; N ; q'
# }



# ----------------------------------------------------------------------------
# #### T R A D U T O R E S   e   D I C I O N Ã R I O S           (Internet)
# ----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# http://babelfish.altavista.digital.com
# Faz traduÃ§Ãµes de palavras/frases/textos entre idiomas.
# Basta especificar quais os idiomas de origem e destino e a frase.
# Obs.: Se os idiomas forem omitidos, a traduÃ§Ã£o serÃ¡ inglÃªs -> portuguÃªs.
#
# Idiomas: pt_en pt_fr es_en es_fr it_en it_fr de_en de_fr
#          fr_en fr_de fr_el fr_it fr_pt fr_nl fr_es
#          ja_en ko_en zh_en zt_en el_en el_fr nl_en nl_fr ru_en
#          en_zh en_zt en_nl en_fr en_de en_el en_it en_ja
#          en_ko en_pt en_ru en_es
#
# Uso: zzdicbabelfish [idiomas] palavra(s)
# Ex.: zzdicbabelfish my dog is green
#      zzdicbabelfish pt_en falcÃ£o Ã© massa
#      zzdicbabelfish en_de my hovercraft if full of eels
# ----------------------------------------------------------------------------
zzdicbabelfish ()
{
	zzzz -h dicbabelfish $1 && return
	
	local padrao
	local url='http://babelfish.altavista.com/babelfish/tr'
	local extra='ienc=iso-8859-1&doit=done&tt=urltext&intl=1'
	local ini='^.*<div style=padding[^>]*>'
	local fim='^<\/div>'
	local lang=en_pt

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dicbabelfish; return; }

	if [ "${1#[a-z][a-z]_[a-z][a-z]}" = '' ]
	then
		lang=$1
		shift
	elif [ "$1" = 'i' ]
	then
		lang=pt_en
		shift
	fi

	padrao=$(echo "$*" | sed "$ZZSEDURL")
	$ZZWWWHTML "$url?$extra&urltext=$padrao&lp=$lang" |
		sed -n "
			/$ini/,/$fim/ {
				/$fim/d
				/^$/d
				/$ini/ {
					s/<[^>]*>//g
					s/^...//p
				}
			}"
}


# ----------------------------------------------------------------------------
# http://www.babylon.com
# TraduÃ§Ã£o de UMA PALAVRA em inglÃªs para vÃ¡rios idiomas.
# FrancÃªs, alemÃ£o, japonÃªs, italiano, hebreu, espanhol, holandÃªs e portuguÃªs.
# Se nenhum idioma for informado, o padrÃ£o Ã© o portuguÃªs.
# Uso: zzdicbabylon [idioma] palavra   #idioma:dut fre ger heb ita jap ptg spa
# Ex.: zzdicbabylon hardcore
#      zzdicbabylon jap tree
# ----------------------------------------------------------------------------
zzdicbabylon ()
{
	zzzz -h dicbabylon $1 && return

	local idioma='ptg'
	local idiomas=' dut fre ger heb ita jap ptg spa '
	local tab=$(echo -e \\t)

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dicbabylon; return; }
	
	# O primeiro argumento Ã© um idioma?
	if [ "${idiomas% $1 *}" != "$idiomas" ]
	then
		idioma=$1
		shift
	fi
	
	$ZZWWWHTML "http://online.babylon.com/cgi-bin/trans.cgi?lang=$idioma&word=$1" |
		sed "
			/SEARCH RESULT/,/<\/td>/!d
			s/^[$tab ]*//
			s/<[^>]*>//g
			/^$/d"
}


# ----------------------------------------------------------------------------
# http://www.portoeditora.pt/dol
# DicionÃ¡rio de portuguÃªs (de Portugal).
# Uso: zzdicportugues palavra
# Ex.: zzdicportugues bolacha
# ----------------------------------------------------------------------------
zzdicportugues ()
{
	zzzz -h dicportugues $1 && return

	local url='http://www.priberam.pt/dlpo/definir_resultados.aspx'
	local ini='^\(NÃ£o \)\{0,1\}[Ff]oi\{0,1\}\(ram\)\{0,1\} encontrad'
	local fim='^Imprimir *$'

	# TODO Verificar alternativa brasileira (enviada por Luciano ES)
	# local URL=http://www.agal-gz.org/estraviz/modules.php
	# local parm='name=Dictionary&file=pesquisar&searchType=exact&dicSearch=maÃ§Ã£'

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dicportugues; return; }

	$ZZWWWDUMP "$url?pal=$1" |
		sed -n "
			s/^ *//
			/^$/d
			s/\[transparent.gif]//
			/$ini/,/$fim/ {
				/$ini/d
				/$fim/d
				p
			}" |
		sed '
			/\(.*\.\),$/ {
		 		s//[\1]/
				H
				s/.*//
				x
			}' # \n + [categoria]
}


# ----------------------------------------------------------------------------
# http://catb.org/jargon/
# DicionÃ¡rio de jargÃµes de informÃ¡tica, em inglÃªs.
# Uso: zzdicjargon palavra(s)
# Ex.: zzdicjargon vi
#      zzdicjargon all your base are belong to us
# ----------------------------------------------------------------------------
zzdicjargon ()
{
	zzzz -h dicjargon $1 && return
	
	local achei achei2 num mais
	local url='http://catb.org/jargon/html'
	local cache=$ZZTMP.jargonfile
	local padrao=$(echo "$*" | sed 's/ /-/g')

	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dicjargon; return; }

	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWLIST "$url/go01.html" |
			sed '
				/^ *[0-9][0-9]*\. /!d
				s@.*/html/@@
				/^[A-Z0]\//!d' > "$cache"
	fi
	
	achei=$(grep -i "$padrao" $cache)
	num=$(echo "$achei" | sed -n '$=')

	[ "$achei" ] || return

	if [ $num -gt 1 ]
	then
		mais=$achei
		achei2=$(echo "$achei" | grep -w "$padrao" | sed 1q)
		[ "$achei2" ] && achei="$achei2" && num=1
	fi

	if [ $num -eq 1 ]
	then
		$ZZWWWDUMP -width=72 "$url/$achei" |
			sed '1,/_\{9\}/d;/_\{9\}/,$d'
		[ "$mais" ] && zztool eco '\nTermos parecidos:'
	else
		zztool eco 'Achei mais de um! Escolha qual vai querer:'
	fi
	
	[ "$mais" ] && echo "$mais" | sed 's/..// ; s/\.html$//'
}


# ----------------------------------------------------------------------------
# Usa todas as funÃ§Ãµes de dicionÃ¡rio e traduÃ§Ã£o de uma vez.
# Uso: zzdictodos palavra
# Ex.: zzdictodos Linux
# ----------------------------------------------------------------------------
zzdictodos ()
{
	zzzz -h dictodos $1 && return

	local dic
	
	# VerificaÃ§Ã£o dos parÃ¢metros
	[ "$1" ] || { zztool uso dictodos; return; }
	
	for dic in babelfish babylon jargon portugues
	do
		zztool eco "zzdic$dic:"
		zzdic$dic $1
	done
}


# ----------------------------------------------------------------------------
# http://aurelio.net/doc/misc/ramones.txt
# Mostra uma frase aleatÃ³ria, das letras de mÃºsicas da banda punk Ramones.
# Obs.: Informe uma palavra se quiser frases sobre algum assunto especifico.
# Uso: zzramones [palavra]
# Ex.: zzramones punk
#      zzramones
# ----------------------------------------------------------------------------
zzramones ()
{
	zzzz -h ramones $1 && return

	local url='http://aurelio.net/doc/misc/ramones.txt'
	local cache=$ZZTMP.ramones
	local padrao=$1

	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWDUMP "$url" > "$cache"
	fi

	# Mostra uma linha qualquer (com o padrÃ£o, se informado)
	zzlinha -t "${padrao:-.}" "$cache"
}


# ----------------------------------------------------------------------------
# http://www.ibb.org.br/vidanet
# A mensagem "Feliz Natal" em vÃ¡rios idiomas.
# Uso: zznatal [palavra]
# Ex.: zznatal                   # busca um idioma aleatÃ³rio
#      zznatal russo             # Feliz Natal em russo
# ----------------------------------------------------------------------------
zznatal ()
{
	zzzz -h natal $1 && return

	local url='http://www.ibb.org.br/vidanet/outras/msg239.htm'
	local cache=$ZZTMP.natal
	local padrao=$1

	# Se o cache estÃ¡ vazio, baixa listagem da Internet
	if ! test -s "$cache"
	then
		$ZZWWWDUMP "$url" | sed '
			/^      /!d
			/\[/d
			s/^  *//
			/^Outras/d
			s/^(/ChinÃªs  &/
			s/  */: /' > "$cache"
	fi

	# Mostra uma linha qualquer (com o padrÃ£o, se informado)
	echo -n '"Feliz Natal" em '
	zzlinha -t "${padrao:-.}" "$cache"
}


# ----------------------------------------------------------------------------
## Incluindo as funÃ§Ãµes extras
[ "$ZZEXTRA" -a -f "$ZZEXTRA" ] && source "$ZZEXTRA"


# ----------------------------------------------------------------------------
## Lidando com a chamada pelo executÃ¡vel

# Se hÃ¡ parÃ¢metros, Ã© porque o usuÃ¡rio estÃ¡ nos chamando pela
# linha de comando, e nÃ£o pelo comando source.
if [ "$1" ]
then

	case "$1" in
	
		# Mostra a tela de ajuda
		-h | --help)
	
			cat - <<-FIM

				Uso: funcoeszz <funÃ§Ã£o> [<parÃ¢metros>]
				     funcoeszz <funÃ§Ã£o> --help

				Dica: Inclua as FunÃ§Ãµes ZZ no seu login shell,
				      e depois chame-as diretamente pelo nome:

				    prompt$ funcoeszz zzzz --bashrc
				    prompt$ source ~/.bashrc
				    prompt$ zz<TAB><TAB>

				Lista das funÃ§Ãµes:

				    prompt$ funcoeszz zzzz

			FIM
		;;

		# Mostra a versÃ£o das funÃ§Ãµes
		-v | --version)
			echo "FunÃ§Ãµes ZZ v$ZZVERSAO"
		;;
	
		# Chama a funÃ§Ã£o informada em $1, caso ela exista
		*)
			func="$1"

			# Garante que a zzzz possa ser chamada por zz somente
			[ "$func" = 'zz' ] && func='zzzz'
			
			# O prefixo zz Ã© opcional: zzdata e data funcionam
			func="zz${func#zz}"
			
			# A funÃ§Ã£o existe?
			if type $func >/dev/null 2>&1
			then
				shift
				$func "$@"
			else
				echo "FunÃ§Ã£o inexistente '$func' (tente --help)"
			fi
		;;
	esac
fi
